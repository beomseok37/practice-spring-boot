## JPA Shop

### 의존성

- Framework: Spring Boot 3.2.2
- Language: Java 17
- DB, ORM: H2, JPA(Hybernate)
- WEB: Thymeleaf 
- Test: Spring-Test(Junit5, assertj)
- ETC: Lombok, Spring-Boot(Validation, devtools)

### 기능

- 회원
  - 회원 등록
  - 회원 조회
- 상품
  - 상품 등록
  - 상품 수정
  - 상품 조회
- 주문
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문 시 배송 정보를 입력할 수 있다.

### Table
![테이블](./img/table.png)

### 기록

- 외래 키가 있는 곳을 연관관계의 주인으로 정한다.
  - 연관관계의 주인은 비즈니스 상에 우위에 있는 것이 아니고 외래키를 누가 관리하느냐의 문제이다.
- `Getter`는 열어두고 `Setter`는 닫혀있어야 한다.
  - 엔티티와 같은 경우 `Setter`를 열어두기보다는 따로 메서드를 선언하여 해당 메서드를 통해서만 생성될 수 있도록 하는 것이 좋다.
- `@ManyToMany`는 사용하지 말자. 중간 테이블의 값을 설정할 수 없고, 세밀한 쿼리를 실행하기 어렵다. `@ManyToOne`, `@OneToMany`로 매핑하자.
- `@XxxToOne`인 관계의 fetch 타입은 항상 `LAZY`로 설정해야 한다.
  - `EAGER`일 경우 예측이 어렵고 N+1 문제가 발생하기도 하고, 최악의 경우 관계가 있는 모든 테이블을 조회하는 경우가 생길 수 있다.
  - 연관된 엔티티 조회 시 fetch join 또는 엔티티 그래프 기능을 사용하자
- Cascade 옵션을 통해 한 엔티티가 받은 영향이 관계된 엔티티에도 퍼질 수 있도록 한다.
- 컬렉션은 필드에서 바로 초기화 해주어야 안전하다.
- ENUM 타입을 Entity 내에서 사용할 경우 `EnumType.STRING`을 선언해주어야 한다.
- `@Embeddable`의 기본 생성자를 protected로 열어두어야 JPA 구현 라이브러리가 객체를 생성할 때 리플랙션과 같은 기술을 사용할 수 있도록 지원할 수 있다.
- 다른 Entity와 관계를 맺고 있는 Entity는 연관관계 메서드를 선언해줌으로써 관계 주입 시 동시에 양방향에 넣어줄 수 있도록 해준다.
  - 연관관계 메서드의 위치는 좀 더 관계를 주도하는 쪽에 넣어주는 것이 좋다.
- Service가 DB에 접근한다면 `@Transactional`을 통해 하나의 트랜잭션 안에서 실행되도록 한다.
  - `readonly = true` 를 설정해주면 읽기 전용으로 더티체크와 같은 영속성 컨텍스트가 할 일이 줄어 약간의 성능이 향사된다.
  - 사실 조회 관련 서비스가 더 많기 때문에 전체적으로 `readonly = true`를 선언하고 삽입, 수정, 삭제 등에 따로 @Transactional을 선언해주자
- test에 application.yml을 따로 선언해주면 test는 해당 설정을 따라간다.
  - H2 DB의 기본 설정이 없을 경우 메모리 DB 방식으로 운영된다.
- 엔티티에 필요한 대부분의 로직은 엔티티 내부에 있고, 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다. (도메인 모델 패턴)
  - [도메인 모델 패턴](http://martinfowler.com/eaaCatalog/domainModel.html)
  - [트랜잭션 스크립트 패턴](http://martinfowler.com/eaaCatalog/transactionScript.html)
- 클라이언트로부터 전달받은 객체는 Entity와 별개로 dto로 따로 정의해주는 것이 좋다.
  - 엔티티 내부에 화면에 처리하기 위한 기능이 많아진다면 유지보수가 어려워진다.
  - 엔티티에는 핵심 로직만 가지고 있도록 하고, dto를 활용해 화면이나 API 요구사항을 처리하도록 하자
- 영속성 컨텍스트가 관리하지 않는 준영속 컨텍스트는 merge로 수정하지 말자
  - merge를 통해 수정할 경우 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 바꾸어버린다.
  - 그러므로 원하는 영속 엔티티를 우선 조회한 뒤 원하는 값만 수정해주어서 영속성 컨텍스트가 더티 체킹으로 이를 알아서 수정하고 DB에 넣어주도록 하자.
    - 컨트롤러에서 어설프게 엔티티를 생성하지 말자.
    - 트랜잭션이 있는 서비스 계층에 식별자(id)와 변경할 데이터를 명확하게 전달
    - 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회, 엔티티 데이터를 직접 변경
    - 트랜잭션 커밋 시점에 변경 감지가 실행된다.

---

# 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화

## 섹션 1

엔티티를 RequestBody, ResponseBody에 활용할 경우 문제점

- 엔티티에 프레젠테이션 계층을 위한 로직이 추가된다. (validation 관련 로직 등등)
- 다양한 API와 관련된 로직들이 엔티티에 담기게 된다.
- 엔티티가 변경되면 API 스펙이 변경된다.

-> API 요청 스펙에 맞추어 별도의 DTO를 만드는 것이 좋다.

DTO 활용

- 엔티티와 프레젠테이션 계층을 위한 로직이 분리된다.
- 엔티티를 그대로 노출시키지 않아 API 스펙과 분리할 수 있다.
- 엔티티가 변해도 API 스펙은 변하지 않는다.

컬렉션 반환 시 문제점

- API 스펙을 변경하기 어렵다.

-> 별도의 클래스를 통해 object 형식으로 반환되어야지만 api 스펙 변화에 유연하게 대처할 수 있다.

---

## 섹션 3

- 엔티티를 프레젠테이션 계층에 직접 노출시키는 것은 역시 좋지 않다.
  - 지연로딩으로 프록시 객체로 존재하는 필드는 json으로 어떻게 생성할지 모른다. <- 해결 방법은 있으나 이렇게 하지 말자
  - 양방향 연관관계가 걸릴 경우 무한 루프에 걸릴 수 있다.
- 엔티티를 DTO로 변환해서 반환하는 것이 일반적이다.
  - 따로 최적화하지 않을 경우 N+1번 쿼리가 발생할 수 있으니 조심해야 한다.
  - 현재 스프링 부트 3.0 이상 + 하이버네이트 6 일 경우 `@OneToOne` 관련 이슈들이 발생하고 있다...
- fetch join을 활용하면 한 번의 쿼리로 엔티티와 연관된 엔티티들을 모두 가져와준다.
- JPQL 기본 join을 통해 원하는 필드값만 조회하고 싶다면 따로 DTO를 구성하면 된다.

> fetch join은 엔티티와 연관된 엔티티를 한번에 가져올 수 있고 여기서 원하는 데이터들을 stream()을 통해 생성할 수 있으므로 유연하게 사용할 수 있다.
> 
> 기본 join과 원하는 필드만 존재하는 DTO를 생성한 경우에 네트웍 용량을 최적화할 수 있고 해당 API 스펙에만 고정되어 있으므로 재사용성은 떨어진다.
> 
> 위 두 가지 방법 모두 장단점이 존재하므로 상황에 따라서 선택해서 사용하면 된다.

권장 순서

- 우선 엔티티를 DTO로 변환하는 방법을 선택
- 필요하면 페치 조인으로 성능 최적화
- 그래도 안되면 DTO로 직접 조회하는 방벙르 사용
- 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해 직접 SQL을 사용한다.

---

## 섹션 4

- 페치 조인 실행 시 쿼리를 한 번만 실행하여 연관된 모든 엔티티를 가져올 수 있다.
- `distinct` 조건을 추가하면 중복된 엔티티를 제거할 수 있다.
- 컬렉션 패치 조인 시 페이징이 불가능하다.
  - 컬렉션 패치 조인 시 DB에서 데이터를 읽어오고 메모리에서 페이징을 해버리기 때문에 위험하다
- ToOne 관계는 패치 조인을 해도 페이징이 가능하다.
- 컬렉션 지연 로딩 시
  - `default_batch_fetch_size`, `@BatchSize`를 적용한다.
  - 컬렉션이나 프록시 객체를 한꺼번에 설정한 사이즈만큼 IN 쿼리로 조회해준다.
  - 페치 조인 방식과 비교해 쿼리 호출 개수는 증가하지만, DB 데이터 전송량이 감소한다.
  - 컬렉션 페치 조인은 페이징이 불가능하지만 이 방법은 가능하다.


엔티티 조회 방법

- 엔티티를 조회해서 그대로 반환
- 엔티티를 조회해서 DTO로 변환해서 반환
- 페치 조인으로 쿼리 수 최적화
- 컬렉션 관련
  - 페치 조인 but 페이징 불가능
  - ToOne 관계만 패치 조인, batch size 설정으로 최적화
- DTO 직접 조회
  - JPQL을 통해 DTO 직접 조회
  - 컬렉션 조회 최적화를 위해 IN 절 활용
  - 플랫 데이터 최적화 (JOIN 결과를 원하는 형태로 직접 변환)

권장 순서

- 엔티티 조회 방식으로 우선 접근
- 페치 조인으로 쿼리 수 최적화
- 컬렉션 최적화
  - 페이징이 필요하면 BatchSize 설정
  - 페이징이 필요 없다면 페치 조인
- 엔티티 조회 방식으로 안되면 DTO 조회 방식 사용
- DTO 조회 방식으로 해결이 안되면 NativeSQL or JdbcTemplate

> 엔티티 조회하는 방식과 페치 조인을 적절하게 사용하고 BatchSize는 디폴트 설정으로 해두자
> 
> 엔티티 조회로 성능이 나지 않다면 DTO를 설계해 적절하게 함께 사용하자
> 
> 성능 최적화화 코드 복잡도는 서로 트레이드 오프 관계이다.

---

OSIV

- Open Session In View: 하이버네이트
- Open EntityManager In View: JPA
- `spring.jpa.open-in-view: true`
  - 기본값이다.
  - 어플리케이션 시작 지점에 warn이 남는 것을 확인할 수 있다.
  - 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지한다.
  - 컨트롤러 상에서도 영속성 컨텍스트가 유지된다. -> 지연 로딩이 가능하다.
  
  -> 커넥션 리소스 사용 시간이 길기 때문에 실시간 트래팩이 중요한 어플리케이션에서는 커넥션이 모자랄 수 있다.
- `spring.jpa.open-in-view: false`
  - 트랜잭션 종료 시 영속성 컨텍스트를 닫고 데이터베이스 커넥션도 반환한다.
  - 컨트롤러 상에서 지연 로딩이 동작하지 않는다. 트랜잭션 내부에서 처리해야 한다.
  - Command와 Query를 분리해서 해결하자!
  - 핵심 비즈니스 로직과 화면이나 API에 집중된 서비스를 구분하자

> 고객 실시간 응답이 필요한 서비스에서는 OSIV를 끄고, ADMIN처럼 커넥션을 많이 사용하지 않는 곳은 OSIV를 키자
> 
> 정말 핵심적인 로직과 화면 혹은 API를 위한 Service를 분리하는 것은 유지보수 관점에서 의미가 있다!