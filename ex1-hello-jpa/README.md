## 섹션 1

지금 시대는 객체를 관계형 DB에서 관리하고 있다. (물론 NoSQL도 있음)

SQL 중심적인 개발의 문제점

- 지나치게 반복되는 CRUD 코드 작성
- 객체를 SQL로
- SQL을 다시 객체로
- 새로운 필드가 추가될 경우 모든 SQL 수정

-> SQL에 의존적인 개발을 피하기 어렵다...

객체를 영구히 저장하기 위한 현실적인 대안은 관계형 데이터베이스이다.

객체를 관계형 데이터베이스에 저장할 경우 우리는 객체와 데이터베이스를 연결해주는 매퍼 역할을 한다.

객체 vs 관계형 데이터베이스

- 객체 상속 관계 : Table 슈퍼타입 서브타입 관계

  - Insert: 하나의 객체를 분해해 각각의 테이블에 저장해주어야 한다.
  - Select: 각각의 테이블에서 조회, 객체 생성 ...
  - 조회, 삽입 시에 추가적인 작업이 필요...

  -> 자바 컬렉션에 저장하듯 사용할 수 없을까?

- 연관관계

  - 객체는 참조, 테이블은 외래 키를 사용
  - 객체 다운 모델링을 사용할 경우 SQL문에 사용 시 불편함..
  - 객체는 연관된 객체를 모두 탐색할 수 있지만, SQL문을 통해 모든 연관된 객체를 항상 미리 로딩할 수는 없다.

  -> 진정한 의미의 계층 분할이 어렵다.

- 비교

  - SQL문을 통해 얻은 값을 통해 객체를 생성했을 경우 항상 새로운 객체를 생성해줌으로 같은 ID를 통해 생성된 객체일지라도 다른 값이 된다.
  - 자바 컬렉션에 저장 후 조회할 경우 같은 객체로 인식한다.

  -> SQL로 동일 값을 얻어올 경우 같은 값으로 인식해주기 위한 추가작업이 필요

객체, SQL 사용시 객체답게 모델링하기 위해 매핑 작업만 늘어난다.

객체를 자바 컬렉션에 저장하듯이 사용할 수 있는 방법을 고민하다 만들어진 것이 JPA이다.

JPA?

> - Java Persistent API(JPA)
> - 자바 진영의 ORM 기술 표준

ORM

- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로, RDB는 RDB대로 설계 가능
- ORM이 객체와 RDB 중간에서 매핑

JPA

- JPA는 어플리케이션과 JDBC 사잉에서 동작한다.
- 객체를 DB에 삽입 시 필요한 객체 분석, 쿼리 작성, JDBC api 연결 등을 모두 알아서 해준다.
- JPA는 인터페이스의 모음으로 하이버네이트 구현체를 사용한다.

JPA 사용 이유

- SQL 중심적인 개발에서 객체 중심 개발으로
- 생산성: 저장, 조회, 수정, 삭제 등을 모두 한 줄의 코드로 작성할 수 있다.
- 유지보수: 필드 추가 시 모든 SQL문을 변경해줄 필요가 없다.
- 패러다임 불일치 해결
  - 상속, 연관관계, 객체 탐색, 객체 비교 등을 알아서 처리해준다.
- 성능₩
  - 1차 캐시와 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 지연 로딩
- 데이터 접근 추상화와 벤더 독립성
- 표준

---
