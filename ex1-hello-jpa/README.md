## 섹션 1

지금 시대는 객체를 관계형 DB에서 관리하고 있다. (물론 NoSQL도 있음)

SQL 중심적인 개발의 문제점

- 지나치게 반복되는 CRUD 코드 작성
- 객체를 SQL로
- SQL을 다시 객체로
- 새로운 필드가 추가될 경우 모든 SQL 수정

-> SQL에 의존적인 개발을 피하기 어렵다...

객체를 영구히 저장하기 위한 현실적인 대안은 관계형 데이터베이스이다.

객체를 관계형 데이터베이스에 저장할 경우 우리는 객체와 데이터베이스를 연결해주는 매퍼 역할을 한다.

객체 vs 관계형 데이터베이스

- 객체 상속 관계 : Table 슈퍼타입 서브타입 관계

  - Insert: 하나의 객체를 분해해 각각의 테이블에 저장해주어야 한다.
  - Select: 각각의 테이블에서 조회, 객체 생성 ...
  - 조회, 삽입 시에 추가적인 작업이 필요...

  -> 자바 컬렉션에 저장하듯 사용할 수 없을까?

- 연관관계

  - 객체는 참조, 테이블은 외래 키를 사용
  - 객체 다운 모델링을 사용할 경우 SQL문에 사용 시 불편함..
  - 객체는 연관된 객체를 모두 탐색할 수 있지만, SQL문을 통해 모든 연관된 객체를 항상 미리 로딩할 수는 없다.

  -> 진정한 의미의 계층 분할이 어렵다.

- 비교

  - SQL문을 통해 얻은 값을 통해 객체를 생성했을 경우 항상 새로운 객체를 생성해줌으로 같은 ID를 통해 생성된 객체일지라도 다른 값이 된다.
  - 자바 컬렉션에 저장 후 조회할 경우 같은 객체로 인식한다.

  -> SQL로 동일 값을 얻어올 경우 같은 값으로 인식해주기 위한 추가작업이 필요

객체, SQL 사용시 객체답게 모델링하기 위해 매핑 작업만 늘어난다.

객체를 자바 컬렉션에 저장하듯이 사용할 수 있는 방법을 고민하다 만들어진 것이 JPA이다.

JPA?

> - Java Persistent API(JPA)
> - 자바 진영의 ORM 기술 표준

ORM

- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로, RDB는 RDB대로 설계 가능
- ORM이 객체와 RDB 중간에서 매핑

JPA

- JPA는 어플리케이션과 JDBC 사잉에서 동작한다.
- 객체를 DB에 삽입 시 필요한 객체 분석, 쿼리 작성, JDBC api 연결 등을 모두 알아서 해준다.
- JPA는 인터페이스의 모음으로 하이버네이트 구현체를 사용한다.

JPA 사용 이유

- SQL 중심적인 개발에서 객체 중심 개발으로
- 생산성: 저장, 조회, 수정, 삭제 등을 모두 한 줄의 코드로 작성할 수 있다.
- 유지보수: 필드 추가 시 모든 SQL문을 변경해줄 필요가 없다.
- 패러다임 불일치 해결
  - 상속, 연관관계, 객체 탐색, 객체 비교 등을 알아서 처리해준다.
- 성능₩
  - 1차 캐시와 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 지연 로딩
- 데이터 접근 추상화와 벤더 독립성
- 표준

---

## 섹션 2

JPA 실습

Dialect

- JPA는 특정 데이터베이스에 종속되지 않는다.
- 데이터베이스마다 문법과 함수에 약간씩 차이가 있다.
- JPA는 방언을 사용함으로써 하나의 코드로도 여러 데이터베이스에 적용할 수 있다.
- 하이버네이트는 40가지 이상의 데이터베이스 방언을 지원한다.

JPA 구동 방식

- Persistence 클래스를 통해 설정정보를 기반으로 EntityManagerFactory를 생성
- EntityManagerFactory가 필요할 때마다 EntityManager를 만들어 구동한다.
- EntityManagerFactory는 하나만 생성해서 어플리케이션 전체에서 공유한다.
- EntityManager는 쓰레드간 공유하면 안된다. (사용하면 버려야 한다.)
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다.

JPQL

- EntityManager를 통해서 단순한 조회나 삽입, 수정, 삭제를 수행할 수 있지만, 조금 복잡한 쿼리를 실행할 수는 없다.
- SQL을 추상화한 객체 지향 쿼리 언어를 제공해준다.
- SQL 문법과 유사하면서, 엔티티 객체를 대상으로 쿼리할 수 있게 해준다.

-> 객체 지향 SQL

---

## 섹션 3

영속성 컨텍스트

- 엔티티를 영구 저장하는 환경이라는 뜻
- 논리적인 개념이다.(눈에 보이지 않는다.)
- EntityManager를 통해 영속성 컨텍스트에 접근할 수 있다.

엔티티 생명주기

- 비영속: 영속성 컨텍스트와 관계가 없는 새로운 상태
  - 객체를 생성했지만 EntityManager를 통해 persist하지 않은 경우
- 영속: 영속성 컨텍스트에 의해 관리되고 있는 상태
  - 객체 생성후 persist를 통해 영속화한 경우
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속화된 엔티티를 영속성 컨텍스트에서 분리한 경우
- 삭제: 삭제된 상태
  - 객체를 삭제한 경우

영속성 컨텍스트의 이점

- 1차 캐시
  - 엔티티 생성 후 영속성 컨텍스트에 넣을 경우 PK를 키로, Entity를 밸류로 1차 캐시에 저장하게 된다.
  - 1차 캐시에 저장된 엔티티는 이후 다시 조회하게 될 경우 DB에 접근하지 않고 1차 캐시에 있는 엔티티를 읽어 주게 된다.
- 동일성 보장
  - 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공한다.
- 트랜잭션을 지원하는 쓰기 지연
  - EntityManager를 통해 persist하는 경우 바로 DB에 insert를 하는 것이 아니라 쓰기 지연 SQL 저장소에 insert SQL을 저장해두고 transaction이 commit될 경우 insert SQL을 통해 삽입하고 commit 된다.
- 변경 감지 (Dirty Checking)
  - 영속성 컨텍스트에 의해 관리되고 있는 객체는 1차 캐시에 저장될 때 첫 모습을 스냅샨으로 저장해둔다.
  - flush가 발생할 경우 스냅샷과 현재 엔티티를 비교해 변경된 부분이 있다면 update SQL을 생성해 쓰기 지연 SQL 저장소에 저장한다.
  - update 관련 SQL을 DB에 전달하고 commit 된다.
- 지연 로딩 (Lazy Loading)

플러시

> 영속성 컨텍스트의 변경내용을 데이터베이스에 반영

- 변경된 부분은 없는지 확인한다.
- 수정된 엔티티와 관련된 update를 위해 쓰기 지연 SQL 저장소에 등록한다.
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)
- `em.flush()`를 통해 직접 호출할 수 있다.
- 트랜잭션 커밋, JPQL 쿼리 실행 시 플러시가 자동 호출된다.
  - 여러 객체를 영속화한 다음 같은 트랜잭션 내부에서 JPQL문을 통해 해당 객체들을 조회하는 쿼리를 실행할 경우 아직 DB에 저장된 내용이 없으므로 조회문으로 객체들을 읽을 수 없다. 그러므로 JPQL 실행 시 일단 flush를 실행한 다음 JPQL 쿼리를 실행한다.
- 플러시를 했다고 영속성 컨텍스트를 비우지 않는다. 영속성 컨텍스트의 내용과 DB의 내용을 동기화하는 작업이다.
- 트랜잭션이라는 작업 단위가 있기 때문에 가능한 것이다. 삽입을 하든, 수정을 하든 트랜잭션 단위 내부에서 커밋 직전에만 동기화하면 되니까.

준영속 상태

- 영속 상태의 엔티티를 영속성 컨텍스트에서 분리한 상태
- 영속성 컨텍스트가 제공하는 기능을 사용할 수 없게 된다.

정리

영속성 컨텍스트

- 엔티티를 저장하기 위한 환경이다.
- 1차 캐시, 지연 SQL 저장소가 존재한다.
- 1차 캐시에서는 엔티티의 PK 값을 키로 엔티티 객체를 밸류로 저장해두고, 1차 캐시에 조회하려는 엔티티가 존재하는 경우 DB에 접근하지 않고 영속성 컨텍스트의 엔티티를 조회할 수 있다.
- 1차 캐시에 저장된 엔티티의 초기 상태를 스냅샷으로 저장해두고 있어 flush 시점에 현재 엔티티의 상태와 스냅샷을 비교해 변경이 있을 경우 이를 DB에 자동 반영해준다.
- 엔티티에 대한 삽입, 수정 삭제 등이 일어난 경우 지연 SQL 저장소에 해당 SQL을 일단 저장해두고 트랜잭션이 커밋되기 직전 시점에 이를 DB에 전달해주게 된다.

엔티티 생명주기

- 비영속 상태: 기본적으로 그냥 생성된 객체
- 영속 상태: 영속성 컨텍스트에 의해 관리되고 있는 객체
- 준영속 상태: 영속성 컨텍스트의 관리에서 분리된 상태
- 삭제 상태: 삭제된 상태

---
