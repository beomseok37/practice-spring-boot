# Compnany

> 회사 내 팀, 멤버들의 출퇴근 관리를 위한 프로젝트입니다.

## 기술 스택

- Spring Boot: 3.2.3
- DB: MySQL (JPA)
- JAVA: 11

## 요구사항

1. 프로젝트 설정, 기본 기능
   1. 프로젝트 초기 설정
   2. 팀 등록 기능
   3. 멤버 등록 기능
   4. 팀 조회 기능 (팀 이름, 팀 매니저 이름, 팀 인원 수)
   5. 직원 조회 기능 (직원 이름, 소속 팀 이름, 역할, 생일, 입사일)
2. 출퇴근
   1. 출근 기능
      1. 등록되지 않은 직원이 출근하려는 경우
      2. 출근한 직원이 또 다시 출근하려는 경우
      3. 이미 출근과 퇴근을 한 직원이 다시 출근하는 경우
   2. 퇴근 기능
      1. 퇴근하려는 직원이 출근하지 않았던 경우
   3. 특정 직원의 날짜별 근무 시간 조회 기능
3. 연차
   1. 연차 신청 기능
      1. 하루 단위로 신청 가능
      2. 올해 입사자는 11개 사용 가능, 그 외에는 15개 사용 가능
      3. 연차 사용일 기준 며칠 전에 연차 등록을 해야 한다.
         1. 팀마다 연차 등록 제한 기간이 다르다
   2. 연차 조회
   3. 특정 직원의 날짜별 근무시간 조회 (응답에 연차 사용 여부가 포함된다.)
4. 초과 근무
   1. 초과 근무 계산
      1. 하루 근무 시간은 8시간
      2. 주말과 법적 공휴일 제외
      3. 초과 근무 시간을 분 단위로 계산
   2. csv 혹은 엑셀 형태 생성


## 구현

### 1.1 프로젝트 설정

프로젝트 초기 설정은 [start.spring.io](https://start.spring.io/)에서 구성했습니다.

추가해준 의존성은 다음과 같습니다.

```bash
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.mysql:mysql-connector-j'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

- DB로 mysql을 사용했으므로 Java 플랫폼의 표준화된 데이터베이스 드라이버인 Connector를 추가했습니다.
- 테이블과 객체 매핑을 도와주고 코드를 통한 쿼리 작성을 도와주는 Spring Data Jpa를 추가했습니다.
- Rest Api 구성을 위해 Spring Web을 추가해주었습니다.

---

### 1.2 ~ 1.3 팀, 멤버 등록

`Team`과 `Member`의 관계는 1:N의 관계로 설정해주었습니다.

엔티티 연관관계의 주인은 N쪽인 Member에게 있으므로 `@JoinColumn`은 Member엔티티에 선언해주었습니다.

🧐**각 팀 당 존재할 수 있는 매니저는 한 명으로 제한을 두어야 합니다.️**🧐

`Team`의 등록은 `Member`가 존재하지 않아도 가능하도록 했습니다. `Member`의 등록은 등록할 팀이 무조건 존재하도록 설계했습니다.

그러므로 `Member` 등록 시 `teamId`를 통해 해당 id의 `Team`을 조회하는 쿼리가 한 번 발생하게 됩니다.

---

### 1.4 팀 조회 기능

팀 조회 시 팀의 매니저 이름(없다면 `null`)과 팀 인원 수를 조회해야 합니다.

저와 같은 경우 매니저와 관련된 컬럼이 멤버에 존재하고 멤버 수를 확인해야 하므로 멤버 테이블 또한 조회해 주어야 합니다.

거의 모든 조회는 Entity 그대로를 조회하는 방식을 사용했습니다. 그러나 LAZY Fetch로 인한 N+1 쿼리가 발생하지 않도록 Fetch Join을 사용해주었습니다.

먼저 `Team` Entity를 조회하고 팀에 소속된 멤버들 중 매니저를 한 명 한 명 확인하는 방식으로 진행했습니다.

🥸 다른 방법으로는 Team 테이블 내에 팀 인원 수와 매니저 이름을 가지고 있는 경우도 가능할 것이라고 생각합니다.

팀에 대한 멤버가 굉장히 많은 경우 모든 멤버를 fetch 해서 가져와 로직을 수행하는 것은 불필요하기 때문에 조회 시 `Team` 테이블만 조회하면 된다는 것은 장점이 될 수 있습니다.

하지만, 팀에 대한 새로운 멤버가 추가될 때마다 `Team` 엔티티의 수정도 필요하다는 점과 `manager` 속성이 두 개의 테이블 모두에 존재해야 한다는 점이 단점이 될 수 있습니다.

---

### 1.5 직원 조회 기능

직원 조회 기능 또한 Team 이름을 반환해주어야 하기 때문에 Fetch Join을 통해 한 번에 조회할 수 있도록 해주었습니다.

또한, `Member` 테이블에 `teamName` 속성이 존재하다면 불필요한 join이 필요없을 수 있습니다.

---

### 2.1 출근 기능

출근 기능은 등록된 멤버가 출근 등록을 하는 기능입니다.

출근 여부를 확인할 테이블로 `Work`를 선언해주었습니다. `Work` 테이블은 시작 시간과 종료 시간을 `LocalDateTime` 타입으로 저장할 수 있도록 했습니다.

일을 시작할 경우 `startDate`에 현재 시간을 저장하고 `endDate`는 `null`인 상태가 됩니다.

✅ 이번 기능은 수행하기에 앞서 확인해야 할 점들이 많습니다. ✅

1. 등록되지 않은 직원이 출근하려는 경우
2. 출근한 직원이 또 다시 출근하려는 경우
3. 이미 출근과 퇴근을 한 직원이 다시 출근하는 경우

다음과 같은 조건들을 확인하여 로직을 구현해야 합니다.

등록되지 않은 직원 여부 확인은 쿼리문 시 반환 값을 `Optional`로 받아 찾으려는 엔티티가 존재하지 않을 경우 `Exception`을 일으켰습니다.

출근한 직원이 또 다시 출근하려는 경우는 멤버 조회 시 함께 확인할 수 있습니다. 

🧐 **멤버 조회 시 오늘 날짜로 `endDate`가 `null`인 데이터가 있는지 확인해줍니다.** 🧐

이미 출근과 퇴근을 한 직원이 다시 출근한 경우 하루 두 번 출근하는 경우도 있기 때문에 그대로 진행해줍니다.

---

### 2.2 퇴근 기능

일을 종료할 경우 `Work` 테이블 데이터의 `endDate`에 현재 시간을 저장해줍니다.

✅ 이번 기능은 수행하기에 앞서 확인해야 할 점들이 있습니다. ✅

1. 등록되지 않은 직원이 퇴근하려는 경우
2. 퇴근하려는 직원이 출근하지 않았던 경우

등록되지 않은 직원은 조회 시 `Optional` 타입으로 해결할 수 있습니다.

아직 출근하지 않은 직원인지 확인하는 방법은 해당 `Member`가 `endDate`가 `null`인 `Work` 데이터가 있는지 확인하면 됩니다.

`endDate`가 `null`인 `row`가 두 개인 경우?..는 출근 기능에서 출근한 직원이 다시 출근하려는 경우를 잘 구현했다면 발생하지 않을 것이다.

---

### 2.3 특정 직원의 날짜별 근무 시간 조회 기능

기준으로 주어진 날짜 이후의 날짜부터 각 날짜의 근무 시간을 분단위로 계산해 반환해줍니다.

해당 `memberId`의 기준 날짜 이후의 `Work` 정보는 `JPQL` 쿼리문으로 작성해 조회했습니다.

`Duration` 클래스를 이용해 `work_start`와 `work_end` 사이 시간을 분단위로 바로 계산할 수 있었습니다.

`forEach`를 통해 `Response`에 `WorkInfo` `dto`를 넣어 반환해주었습니다.

---

### 3.1 연차 신청 기능

연차와 관련된 테이블 `work_out`을 생성해주었습니다. `work_out`에는 연차 시작 날짜와 종료 날짜가 존재합니다.

`work_out`과 `member` 테이블의 관계는 N:1이고 외래키는 `work_out`에 존재하므로 관계의 주인은 `WorkOut` Entity으로 설정했습니다. 또한, `Cascade` 옵션을 추가해 수정이 발생하면 `DayOff` 엔티티에게도 영향이 가도록 설정했습니다.

명시된 조건 이외에 확인해야 할 점은 다음과 같습니다. 

🧐 해당 날짜에 이미 신청된 연차가 존재하는지 🧐

요청으로 들어온 날짜와 이미 존재하는 연차 중 날짜 비교를 통해 이미 요청된 연차가 있는지 확인하면 될 것 같습니다.

연차 신청 단위는 client로부터 요청 받을 때 시작 날짜와 종료 날짜를 받게 함으로써 하루 단위로만 요청을 받도록 설정했습니다.

올해 입사 여부는 `Member` 테이블의 `work_start_date`를 통해 확인했습니다.

팀마다 존재하는 연차 등록 제한 기간을 위해 `team` 테이블에 `day_off_apply_limit` 컬럼을 추가해줬고 default는 1일로 지정해주었습니다.

메서드 구현 로직의 순서

1. 멤버의 휴가가 남아있는지 확인한다.
   1. `Member` `Entity`를 조회하되, `Team`과 `DayOff` 엔티티를 `Fetch Join`으로 조회하여 다시 조회 쿼리가 발생하지 않도록 한다.
   2. 올해 남은 휴가 일수를 계산하고, 입사 연월을 확인해 현재 요청으로 들어온 휴가를 사용할 수 있는지 확인한다.
2. 멤버가 속한 팀의 휴가 신청 가능 기간인지 확인한다.
3. 실제 `DayOff` 엔티티를 생성해줍니다.
   
---

### 3.2 연차 조회 기능

3.1 기능 구현 중 이미 로직을 구현했기 때문에 이를 그대로 사용해줍니다.

---

### 3.3 특정 직원의 날짜별 근무시간 조회

이전에 2.3에서 구현했던 근무 시간 조회 기능에서 `usingDayOff` 속성이 추가되었습니다.

그래서 `WorkInfo`를 상속받은 `WorkInfoWithDayOff` DTO를 반환할 수 있도록 `WorkResponse`를 제네릭 타입으로 변경했습니다.

해당 로직을 구현하기 위해 기준 날짜 이후의 Work 정보와 DayOff 정보를 모두 얻어오도록 했습니다.

그 이후, `WorkResponse`에 `work` 테이블을 통해 얻은 하루 근무 시간과 `DayOff`에서 얻은 휴가 기간 정보를 모두 넣어줍니다.

각각의 데이터를 따로따로 넣어주었기 때문에 아직 날짜순으로 정렬되어 있지 않습니다. 그러므로 `Comparator`익명 클래스를 통해 날짜순으로 정렬시켜준 뒤 반환해줍니다.

근무 시간, 휴가 기간을 따로 넣고 정렬을 한 이유는 데이터 전체 길이가 최대 31일(한 달만 조회하므로)이기 때문에 따로 넣고 정렬해도 문제 없을 것이라고 생각했기 때문입니다.

---
   
### 4.1 초과 근무 계산

주말과 법정 공휴일을 제외한 근무일 수 * 8로 기준 근무 시간을 계산할 수 있습니다.

주말은 `LocalDate` 클래스를 통해 요일을 숫자(1~7)로 반환되는 것을 이용하면 구할 수 있습니다.

🧐 법적 공휴일은 외부 라이브러리를 활용(icu4j)하거나 2200년까지의 공휴일을 작성해두었다는 DB를 사용해보면 될 것 같다.🧐

우선 주중 일수 * 480을 통해 기준 근무 시간을 분단위로 구해주었습니다.

`Work` 테이블을 `member_id` 컬럼으로 `GROUP BY` 하여 해당 월의 총 근무 시간을 반환받도록 했습니다. 또한 JPQL을 통해 DTO로 바로 PROJECTION 시킬 수 있도록 했습니다.

### 🧐 4.2 csv 혹은 엑셀 형태로 생성 🧐

csv 혹은 엑셀 형태로 작성 방법은 다음 블로그에서 확인할 수 있습니다. -> [블로그](https://www.baeldung.com/java-csv)

만약 실제 구현한다면..

1. 새로운 자바 파일에서 현재 배포된 서버에 초과 근무 계산 요청을 보낸다.
2. 반환 받은 json값을 통해 csv파일을 작성하도록 한다.
3. 리눅스 스케줄러(`crontab`)를 활용해 매달 1일 오전에 자바 파일을 실행한다.

## CI/CD

GitHub에 배포된 상태라면 GitHub Actions를 통해 배포 가능합니다.

방법

1. ssh 접속을 위한 action을 추가합니다.
2. ssh 접속을 위한 HOST, USERNAME, PORT, ssh KEY를 Repository Secrets에 추가해줍니다.
3. ssh 접속 후 실행할 명령어들을 작성해주면 됩니다. (git pull, 프로젝트 실행 명령어 등등)