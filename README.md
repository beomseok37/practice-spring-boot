# practice-spring-boot

spring boot 연습 레포지토리입니다.

## Practice1 요약본

[링크](https://github.com/beomseok37/practice-spring-boot/tree/main/practice1)

> 객체 지향 언어의 특징을 잘 살릴 수 있도록 도와주는 프레임워크인 Spring에 대해 알아보았습니다.

과거 Enterprice Java Bean을 상속받아 개발하는 과정에서 객체지향적인 프로그래밍이 불가능해졌다. 그래서 순수한 자바, 객체지향적인 프로그래밍으로 돌아가기 위해 `POJO`와 같은 개념이 생겨나게 되었고, POJO 프로그래밍을 지향하는 프레임워크인 Spring이 등장하게 되었습니다.

스프링의 핵심 컨셉은 객체 지향 언어가 가진 특징을 가장 잘 살려낼 수 있도록 해주는 것입니다.

겍체 지향 프로그래밍은 **"객체"들의 관계**를 통해 이루어집니다. 각각의 객체는 메시지를 주고 받으며, 데이터를 처리합니다. 이러한 특징을 잘 살린다면 프로그램이 유연해지고 변경이 용이하게 됩니다.

객체 지향 프로그래밍의 특징 중 하나인 **다형성**은 객체를 `역할`과 `구현`으로 나눕니다. 역할은 인터페이스이고 구현은 실제 구현체를 뜻합니다. 클라이언트는 인터페이스를 통해 소통하기 때문에 내부적인 구조에 대해서 알지 못해도 괜찮습니다. 구현체가 변경되더라도 인터페이스에서 정의한 형식이 유지된다면 클라이언트에게는 어떠한 영향도 있지 않습니다.

스프링은 이런 다형성을 극대화할 수 있도록 도와줍니다. 스프링에서 가능한 제어의 역전, 의존 관계 주입은 다형성을 활용해 **인터페이스와 구현체를 편리하게 다룰 수 있게 지원**해줍니다.

스프링이 없이 다형성을 활용한 프로그래밍을 한다면, 다음과 같은 문제에 직면합니다.

```java
MemberRepository memberRepository = new MemoryMemberRepository();
// MemoryMemberRepository->JdbcMemberRepository로 클래스 변경
MemberRepository memberRepository = new JdbcMemberRepository();
```

인터페이스에 대한 구현체를 변경할 경우 클라이언트 코드 상에 구현체 교체와 관련된 수정이 발생하므로 `개방-폐쇄 원칙`을 지키지 못하게 됩니다. 또한, 클라이언트가 인터페이스에 의존하고 있음과 동시에 구현체에게도 의존하고 있어 `의존관계 역전 원칙`을 지키지 못하게 됩니다.

이러한 부분을 해결하기 위해서는 `관심사의 분리`가 필요합니다. 현재 클라이언트 코드 상에는 인터페이스와 연결된 구현체를 결정하는 코드까지 존재하기 때문에 위와 같은 문제가 발생하고 있습니다. 그러므로 인터페이스에 연결시켜줄 **구현체를 결정할 코드를 다른 부분에게 위임**해주면 됩니다. 여기서의 **다른 부분이 프레임워크**가 되는 것입니다.

클라이언트는 인터페이스를 통해 다른 객체와 관계를 맺는 코드만 존재하고 프레임워크가 필요한 구현체를 결정해주는 형태를 `제어의 역전`이라고 합니다. 그리고 결정된 구현체 객체를 주입해주는 것을 `의존 관계 주입`이라고 합니다.

스프링 컨테이너는 `@Configuration`, `@Bean`이 붙은 객체에게 `Dependency Lookup`을 수행하고 스프링 컨테이너에 의해 관리되는 객체를 스프링 빈이라고 합니다. 스프링 컨테이너는 스프링 빈을 필요한 자리에 자동으로 `Dependency Injection`을 수행합니다.

스프링 컨테이너는 XML이나 자바 설정 클래스 기반, Groovy 등 **다양한 설정 형식을 제공**합니다. 이는 `BeanDefinition`로 빈 설정 메타 정보를 추상화했기 때문입니다. 다양한 설정 방식으로 빈을 등록한 뒤 이를 `BeanDefinition`으로 생성하면 스프링 컨테이너에 전달할 수 있습니다.

스프링 컨테이너에서 관리하고 있는 스프링 빈은 싱글톤으로 관리됩니다. 그러므로 스프릥 빈으로 등록할 객체에 변경 가능한 상태값을 정의해서는 안됩니다. `@Configuration`이 선언된 클래스를 **CGLIB 라이브러리**를 통해 조작해 **싱글톤이 보장된 스프링 빈**을 만들게 되므로 `@Bean`**만으로는 싱글톤을 보장받지 못하게 됩니다.**

`@Component` 어노테이션이 선언된 클래스도 `@ComponentScan`을 통해 스프링 빈으로 등록됩니다. 스프링 빈 등록은 클래스 이름을 바탕으로 진행되는데 만약 똑같은 이름의 빈이 존재하게 된다면 예외가 발생하게 됩니다.

의존 관계 주입 방법으로는 `생성자 주입`, `수정자 주입`, `필드 주입`, `일반 메서드 주입`이 있습니다. 이 중 생성자 주입이 가장 추천하는 방법이며, 필드 주입은 간편하지만 스프링에 의존하게 된다는 단점이 존재해 권장하지 않습니다. 하지만, 테스트 코드 내에서 간편하게 사용할 경우에는 필드 주입을 사용해도 무관합니다.

스프링 빈의 생명주기는 `스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> ... -> 소멸 전 콜백 -> 스프링 종료` 입니다.

빈 생명주기와 관련된 콜백 메서드를 정의하는 방법은 `인터페이스`, `설정 정보에 초기화, 종료 메서드 지정`, `어노테이션 지원` 등이 있습니다.

스프링 빈 스코프는 `싱글톤`, `프로토타입`, `웹 관련 스코프`가 존재합니다. 싱글톤은 기본 스코프로 스프링 컨테이너의 **시작부터 종료까지 유지되는 가장 넓은 범위**입니다. 프로토타입은 스프링 **빈을 조회하는 시점에 생성**되고 스프링 컨테이너는 생성, 의존관계 주입, 초기화까지만 관리합니다. 웹 관련 스코프는 **웹 요청, 세션, 서블릿 컨텍스트에 따라 유지**되는 스코프이고 스프링 컨테이너는 시작과 종료 시점까지 관리합니다.

프로토타입 스코프는 싱글톤 빈과 함께 사용할 경우 **빈을 원하는 시점에 주입받기 위해 추가적인 처리를 해줘야 한다**. 웹 관련 스코프 또한, 아직 생성되지 않았을 경우 의존 관계를 맺고 있는 빈이 먼저 생성 될 경우 예외가 발생하므로 **원하는 시점에 주입 받기 위해 따로 처리하거나 프록시 객체를 사용**해줘야 합니다.

## ex1-hello-jpa 요약본

[링크](https://github.com/beomseok37/practice-spring-boot/tree/main/ex1-hello-jpa)

> SQL 중심적인 개발에서 실제 객체를 활용해 DB에 저장하는 방식으로 변할 수 있었던 `JPA` 기술에 대해 배웠습니다.

객체를 DB에 저장할 수 있는 방법으로 관계형 데이터베이스가 있습니다. 관계형 데이터베이스의 테이블을 실제 객체에 매핑 시키기 위해서는 **객체의 상속관계**, **테이블의 연관관계**를 서로에게 연결시켜줘야 합니다. 이를 위해 등장한 것이 **JPA**입니다.

JPA는 `Java Persistent API`로 자바 진영의 ORM 기술 표준입니다. ORM은 `Object-Relational Mapping`으로 객체와 테이블을 매핑시켜주는 기술을 말합니다. JPA는 어플리케이션과 JDBC 사이에서 동작하며 객체와 테이블을 매핑시키는 여러 동작들을 처리해줍니다. JPA는 `인터페이스의 모음`이므로 이를 구현한 대표적인 구현체는 `Hibernate`가 있습니다.

JPA를 활용함으로써 **SQL 중심적이었던 개발을 객체 중심적인 개발로 이동**할 수 있었습니다. JPA를 사용함으로써 생산성과 유지보수 측면 또한 향상시켜주게 되었습니다. 또한, 특정 데이터베이스에 의존하지 않고 여러 데이터베이스에 적용시킬 수 있게 되었습니다.

JPA의 구동방식은 설정정보를 기반으로 `EntityManagerFactory`를 하나만 만들고 필요할 때마다 `EntityManager`를 만들어 구동합니다. `EntityManager`는 사용 후 버리게 되고 JPA의 모든 데이터 변경은 트랜잭션 내에서만 처리해야 합니다. 조금 복잡한 쿼리를 수행할 경우 `JPQL` 문법을 통해 객체 지향적인 쿼리 작성을 할 수 있습니다.

JPA는 `영속성 컨텍스트`를 통해 엔티티를 저장합니다. 영속성 컨텍스트를 통해 `1차 캐시`, `쓰기 지연`, `지연 로딩` 등의 기능을 수행할 수 있습니다.

`@Entit`y가 선언된 클래스는 엔티티로 테이블과 매핑됩니다. 내부 컬럼, 컬럼 데피니션을 통해 **DDL을 생성**할 수 있습니다. 기본 키 매핑은 `@Id`를 통해 가능하고 자동 생성 전략은 `@GeneratedValue`를 통해 이루어집니다.

**테이블은 외래키를 통해 연관 관계를 맺습니다**. 하지만, **객체는 참조를 통해 연관 관계를 맺게 됩니다**. 객체가 단방향 참조로 연관관계를 맺을 경우 테이블에 참조를 선언한 테이블에 외래키를 설정한다면 문제가 되지 않습니다. 하지만, 객체가 서로에게 양방향 참조로 연관관계를 맺고 있다면 하나의 외래키로 연관관계를 맺고 있는 테이블과 혼동이 될 수 있습니다. 그러므로 양방향 연관관계 시 이 **연관관계의 주인을 정해주어야 합니다**. 연관관계의 주인은 해당 연관관계에서 우의를 점하고 있다는 뜻이 아닌 단순히 외래키를 관리한다는 뜻입니다.

외래키를 관리하는 쪽에 단방향 연관관계 매핑을 하는 것만으로 연관관계는 결정됩니다. 필요에 따라서 양방향 매핑으로 변경한다면, **두 객체 모두에게 참조 값을 넣어주는 것**에 유의해주야 합니다.

**상속관계 매핑은 슈퍼타입 서브타입 관계와 유사**합니다. 상속 관계의 객체를 테이블로 매핑 시킬 수 있는 전략으로는 `조인 전략`, `단일 테이블 전략`, `구현 클래스마다 테이블을 생성하는 전략`이 있습니다. 간단한 것이 최우선일 경우 단일 테이블에 모두 넣는 방법이 고려되며, 최근에는 자식 클래스를 json으로 관리하는 경우도 있다고 합니다.

영속성 컨텍스트를 통해 `프록시 객체`를 조회할 수 있습니다. 실제 데이터베이스에서 엔티티를 조회하지 않고 **해당 엔티티 클래스를 상속받은 프록시 객체**를 얻을 수 있습니다. 이후 프록시 객체에서 필드값을 조회하는 메서드를 실행할 경우 영속성 컨텍스트에 실제 값의 초기화 요청을 하게 됩니다. 프록시 객체는 **실제 값을 타겟으로 참조**하고 있기 때문에 실제 필드값을 조회할 수 있습니다.

영속성 컨텍스트 내부에서는 `지연 로딩`이 가능합니다. 지연 로딩이 되기 전 **객체의 참조 값에는 프록시 객체가 존재**하게 됩니다. 실제 참조 값을 조회할 때에 데이터베이스에 실제 참조 값을 조회하는 쿼리가 발생하게 됩니다. 즉시 로딩은 N+1문제와 같이 예상하지 못한 쿼리가 발생할 위험이 있으므로 사용하지 않는 것이 좋습니다.

JPA 쿼리 방법은 `JPQL`, `JPA Criteria`, `QueryDSL`, `Native SQL` 등이 있습니다. JPQL은 JPA가 제공하는 SQL을 추상화한 객체 지향 쿼리 언어입니다. SQL 문법과 비슷하고 쿼리문 안에서 엔티티 객체를 대상으로 쿼리합니다. Criteria는 문자열로 작성하는 JPQL의 문제를 해결하기 위해 전부 자바 코드로 JPQL을 작성합니다. 네이티브 SQL은 실제 SQL 쿼리를 작성할 수 있습니다.

JPQL은 **엔티티 객체를 대상으로 쿼리가 가능**합니다. **실제 SQL문법과 비슷한 문법을 지원**합니다. **프로젝션을 이용해 원하는 컬럼값만 조회**하는 것도 가능합니다. **페이징과 같은 편의 기능도 제공**합니다. `.`**을 통해 참조하고 있는 객체 그래프를 탐색**할 수 있습니다. **성능 최적화를 위해 `Fetch Join`을 제공**함으로써 연관된 엔티티나 컬렉션을 SQL 한번으로 조회할 수 있습니다. JPQL은 **다형성을 위한 기능과 타입 캐스팅 기능**까지 제공하고 있습니다.

JPA의 변경감지 기능이 아닌 한 번에 update하는 벌크 연산을 수행하는 경우 영속성 컨텍스트를 무시하고 직접 쿼리하는 것이기 대문에 **영속성 컨텍스트와 데이터베이스 데이터를 일치**시키는 작업이 필요합니다.

## jpashop 정리본

[링크](https://github.com/beomseok37/practice-spring-boot/tree/main/jpashop)

> JPA와 Spring Starter Web을 통해 실제 api를 구성해보는 프로젝트입니다.

기능은 회원, 상품, 주문의 CRUD이고 기타 요구 사항은 상품은 재고 관리가 가능하고 상품의 종류는 도서, 음반, 영화가 있고 상품을 카테고리로 구분할 수 있고 상품 주문 시 배송 정보를 입력할 수 있다는 것이다.

개발 관련 정리

- 외래 키가 있는 곳을 연관 관계의 주인으로 정한다. 단방향으로도 연관관계를 맺을 수 있다. 꼭 필요한 경우에만 양방향 연관관계를 맺자.
- 양방향 연관관계를 맺을 경우 연관관계 주입 시 동시에 두개 모두 주입해주는 메서드를 따로 작성하는 것이 더 안전하다.
- 최대한 `Getter`만 열어두자. `Setter`와 같은 메서드 보다는 따로 네이밍한 메서드를 통해 필드값을 바꿔주는 것이 더 안전하다.
- `@ManyToMany` 연관관계는 사용하지 말자. 실제 중간 테이블을 직접 생성하는 것이 의도하지 않은 동작을 방지하고 중간 테이블에 필드 추가와 같은 이외 동작을 수행할 수 있다.
- `@XxxToOne` 인 연관관계의 패치 전략을 LAZY로 변경해주자. 즉시 로딩의 경우 조회 시 N+1 문제가 발생할 수 있고 의도치 않은 조인이 발생할 수 있기 때문이다.
- 컬렉션 참조값은 바로 초기화해주어야 한다.
- 서비스 로직은 하나의 트랜잭션 안에서 실행되도록 한다.
- test에 application.yml을 따로 작성하면 해당 설정대로 test가 실행된다. H2 DB는 DB 연결 관련 설정이 없으면 메모리에서 테스트를 실행한다.
- 엔티티에 필요한 대부분의 로직은 엔티티 내부에 작성하고, 서비스 계층은 단순히 엔티티에 필요한 로직을 호출하는 역할을 하도록 한다.
- 엔티티를 프레젠테이션 계층에 노출시키는 것은 좋지 않다. 엔티티가 변경될 경우 API 스펙 전체가 변경되는 경우가 생기기 때문입니다.
- 데이터 수정 시 영속성 컨텍스트의 변경 감지를 사용합니다.

데이터 조회 순서

- 우선 엔티티 형태로 조회 -> DTO로 변환
- 필요할 경우 페치 조인으로 쿼리 수 최적화(페이징이 필요하다면 BatchSize 설정)
- 그래도 안되면 DTO로 직접 조회 (JPQL)
- 최후의 방법은 Native Query 혹은 JDBC Template 사용

`OSIV (Open Session In View)`

- `true`가 기본값이다. 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지한다. -> 컨트롤러에서도 영속성 컨텍스트가 유지된다.
- `false`일 경우 트랜잭션이 종료되면 영속성 콘텍스트를 닫고 데이터베이스 커넥션도 반환한다. -> 핵심 비즈니스 로직과 화면, API 구성 로직을 구분
- 실시간 응답이 필요한 경우 OSIV를 끄고, 많은 커넥션이 필요하지 않은 경우 OSIV를 켜도 된다.
