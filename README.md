# practice-spring-boot

spring boot 연습 레포지토리입니다.

## Practice1

[링크](https://github.com/beomseok37/practice-spring-boot/tree/main/practice1)

> 객체 지향 언어의 특징을 잘 살릴 수 있도록 도와주는 프레임워크인 Spring에 대해 알아보았습니다.

과거 Enterprice Java Bean을 상속받아 개발하는 과정에서 객체지향적인 프로그래밍이 불가능해졌다. 그래서 순수한 자바, 객체지향적인 프로그래밍으로 돌아가기 위해 `POJO`와 같은 개념이 생겨나게 되었고, POJO 프로그래밍을 지향하는 프레임워크인 Spring이 등장하게 되었습니다.

스프링의 핵심 컨셉은 객체 지향 언어가 가진 특징을 가장 잘 살려낼 수 있도록 해주는 것입니다.

겍체 지향 프로그래밍은 **"객체"들의 관계**를 통해 이루어집니다. 각각의 객체는 메시지를 주고 받으며, 데이터를 처리합니다. 이러한 특징을 잘 살린다면 프로그램이 유연해지고 변경이 용이하게 됩니다.

객체 지향 프로그래밍의 특징 중 하나인 **다형성**은 객체를 `역할`과 `구현`으로 나눕니다. 역할은 인터페이스이고 구현은 실제 구현체를 뜻합니다. 클라이언트는 인터페이스를 통해 소통하기 때문에 내부적인 구조에 대해서 알지 못해도 괜찮습니다. 구현체가 변경되더라도 인터페이스에서 정의한 형식이 유지된다면 클라이언트에게는 어떠한 영향도 있지 않습니다.

스프링은 이런 다형성을 극대화할 수 있도록 도와줍니다. 스프링에서 가능한 제어의 역전, 의존 관계 주입은 다형성을 활용해 **인터페이스와 구현체를 편리하게 다룰 수 있게 지원**해줍니다.

스프링이 없이 다형성을 활용한 프로그래밍을 한다면, 다음과 같은 문제에 직면합니다.

```java
MemberRepository memberRepository = new MemoryMemberRepository();
// MemoryMemberRepository->JdbcMemberRepository로 클래스 변경
MemberRepository memberRepository = new JdbcMemberRepository();
```

인터페이스에 대한 구현체를 변경할 경우 클라이언트 코드 상에 구현체 교체와 관련된 수정이 발생하므로 `개방-폐쇄 원칙`을 지키지 못하게 됩니다. 또한, 클라이언트가 인터페이스에 의존하고 있음과 동시에 구현체에게도 의존하고 있어 `의존관계 역전 원칙`을 지키지 못하게 됩니다.

이러한 부분을 해결하기 위해서는 `관심사의 분리`가 필요합니다. 현재 클라이언트 코드 상에는 인터페이스와 연결된 구현체를 결정하는 코드까지 존재하기 때문에 위와 같은 문제가 발생하고 있습니다. 그러므로 인터페이스에 연결시켜줄 **구현체를 결정할 코드를 다른 부분에게 위임**해주면 됩니다. 여기서의 **다른 부분이 프레임워크**가 되는 것입니다.

클라이언트는 인터페이스를 통해 다른 객체와 관계를 맺는 코드만 존재하고 프레임워크가 필요한 구현체를 결정해주는 형태를 `제어의 역전`이라고 합니다. 그리고 결정된 구현체 객체를 주입해주는 것을 `의존 관계 주입`이라고 합니다.

스프링 컨테이너는 `@Configuration`, `@Bean`이 붙은 객체에게 `Dependency Lookup`을 수행하고 스프링 컨테이너에 의해 관리되는 객체를 스프링 빈이라고 합니다. 스프링 컨테이너는 스프링 빈을 필요한 자리에 자동으로 `Dependency Injection`을 수행합니다.

스프링 컨테이너는 XML이나 자바 설정 클래스 기반, Groovy 등 **다양한 설정 형식을 제공**합니다. 이는 `BeanDefinition`로 빈 설정 메타 정보를 추상화했기 때문입니다. 다양한 설정 방식으로 빈을 등록한 뒤 이를 `BeanDefinition`으로 생성하면 스프링 컨테이너에 전달할 수 있습니다.

스프링 컨테이너에서 관리하고 있는 스프링 빈은 싱글톤으로 관리됩니다. 그러므로 스프릥 빈으로 등록할 객체에 변경 가능한 상태값을 정의해서는 안됩니다. `@Configuration`이 선언된 클래스를 **CGLIB 라이브러리**를 통해 조작해 **싱글톤이 보장된 스프링 빈**을 만들게 되므로 `@Bean`**만으로는 싱글톤을 보장받지 못하게 됩니다.**

`@Component` 어노테이션이 선언된 클래스도 `@ComponentScan`을 통해 스프링 빈으로 등록됩니다. 스프링 빈 등록은 클래스 이름을 바탕으로 진행되는데 만약 똑같은 이름의 빈이 존재하게 된다면 예외가 발생하게 됩니다.

의존 관계 주입 방법으로는 `생성자 주입`, `수정자 주입`, `필드 주입`, `일반 메서드 주입`이 있습니다. 이 중 생성자 주입이 가장 추천하는 방법이며, 필드 주입은 간편하지만 스프링에 의존하게 된다는 단점이 존재해 권장하지 않습니다. 하지만, 테스트 코드 내에서 간편하게 사용할 경우에는 필드 주입을 사용해도 무관합니다.

스프링 빈의 생명주기는 `스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> ... -> 소멸 전 콜백 -> 스프링 종료` 입니다.

빈 생명주기와 관련된 콜백 메서드를 정의하는 방법은 `인터페이스`, `설정 정보에 초기화, 종료 메서드 지정`, `어노테이션 지원` 등이 있습니다.

스프링 빈 스코프는 `싱글톤`, `프로토타입`, `웹 관련 스코프`가 존재합니다. 싱글톤은 기본 스코프로 스프링 컨테이너의 **시작부터 종료까지 유지되는 가장 넓은 범위**입니다. 프로토타입은 스프링 **빈을 조회하는 시점에 생성**되고 스프링 컨테이너는 생성, 의존관계 주입, 초기화까지만 관리합니다. 웹 관련 스코프는 **웹 요청, 세션, 서블릿 컨텍스트에 따라 유지**되는 스코프이고 스프링 컨테이너는 시작과 종료 시점까지 관리합니다.

프로토타입 스코프는 싱글톤 빈과 함께 사용할 경우 **빈을 원하는 시점에 주입받기 위해 추가적인 처리를 해줘야 한다**. 웹 관련 스코프 또한, 아직 생성되지 않았을 경우 의존 관계를 맺고 있는 빈이 먼저 생성 될 경우 예외가 발생하므로 **원하는 시점에 주입 받기 위해 따로 처리하거나 프록시 객체를 사용**해줘야 합니다.
