## 배운 내용

### 섹션 1

스프링 프레임워크란?

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

스프링 부트

- 스프링을 편리하게 사용할 수 있도록 해주는 것
- 단독으로 실행할 수 있는 스프링 어플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 어떠한 라이브러리를 사용하기 위해 종속된 다른 라이브러리들까지 설치해야 되는 경우 starter 라이브러리로 한 번에 모두 설치할 수 있도록 도와준다
- 스프링과 외부 라이브러리 버전 호환을 자동으로 구성해준다.
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 설정을 해주고 바꾸고 싶은 부분은 따로 바꿀 수 있다.

스프링의 핵심 컨셉

- 스프링은 자바 언어 기반 프레임워크이다
- 자바의 가장 큰 핵심은 **"객체 지향 언어"** 라는 점이다
- 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내는 프레임워크이다.

즉, 스프링은 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크이다.

> 과거 EJB를 사용하면 EJB를 상속받아 사용하는 과정에서 EJB에 의존적으로 개발을 하게 되었다. -> 객체지향이 가진 장점을 다 잃어버리게 되었다. 그래서 순수한 자바, 객체 지향 프로그래밍으로 돌아가고자 나온 것이 POJO 등이 있는 것이다. 스프링의 DI 컨테이너 등이 객체 지향적으로 개발이 가능하도록 해주고 있다.

그렇다면 **좋은 객체 지향 프로그래밍**이란 무엇인가?

객체 지향 프로그래밍은 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받으며, 데이터를 처리할 수 있다. 객체 지향 프로그래밍은 프로그램을 **유연하고 변경이 용이하게** 만들어준다. 이는 객체 지향의 특징 중 하나인 다형성으로 설명할 수 있다.

다형성

- 세상을 역할(인터페이스)와 구현(구현체)로 나눌 수 있다.
- 운전자의 역할, 자동차의 역할이 있다면, 운전자의 구현체는 나 혹은 다른 사람이 되고 자동차의 구현체는 k3, 아반떼, 테슬라 등이 될 수 있다.
- 운전자가 자동차를 k3에서 아반떼로 바꾸어도 운전자에게는 영향을 주지 않는다.
- 운전자는 자동차의 내부 구조에 대해서 알지 못해도 상관 없다.
- 운전자에게 영향을 주지 않아도 자동차의 새로운 기능을 제공해줄 수 있다.

역할과 구현의 분리

- 역할과 구현으로 구분하면 단순해지고, 유연해지며 변경도 편리하다.
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 자바 언어의 다형성 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 구현 객체

다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

다형성의 한계

- 역할 자체가 변경된다면, 클라이언트 서버 모두 큰 변경이 발생한다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

스프링과 객체 지향

- 다형성이 가장 중요하다!
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전, 의존 관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원해준다.

좋은 객체 지향 설게의 5가지 원칙 (SOLID)

- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존관계 역전 원칙

다형성과 5원칙 위배

- OCP 위배

다형성을 통해 인터페이스와 구현체를 분리하여 개발을 진행할 수 있다. `MemberRepository` 인터페이스를 구현한 클래스 `MemoryMemberRepository`와 `JdbcMemberRepository가`` 있을 때, 앞의 클래스를 사용하다가 뒤의 클래스를 사용하기 위해서는 클라이언트의 코드를 바꿔야 되므로 OCP를 위배하게 된다.

```java
MemberRepository memberRepository = new MemoryMemberRepository();
// MemoryMemberRepository->JdbcMemberRepository로 클래스 변경
MemberRepository memberRepository = new JdbcMemberRepository();
```

- DIP 위배

위의 예시를 살펴보면 MemberRepository라는 인터페이스에 대해 의존하고 있지만, 이를 구현한 클래스인 `MemoryMemberRepository`와 `JdbcMemberRepository`에게도 의존하고 있는 형태로 존재하고 있다. 이는 DIP를 위배하게 된다.

-> 다형성만으로는 좋은 객체 지향(유연하고 변경이 용이한) 프로그래밍을 할 수 없다.

정리

- 객체 지향의 핵심은 다형성이다.
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성만으로는 인터페이스에만 의존하는 것이 아닌 구현 클래스에도 의존하게 된다.

더 쉽게 부품 갈아 끼우듯이 개발하기 위해서는 무엇인가 더 필요하다 -> **스프링!**

스프링의 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.

- **DI(Dependency Injection)**: 의존관계, 의존성 주입
- **DI 컨테이너** 제공: DI 컨테이너 내부에서 객체들을 저장하고 의존 관계를 연결해준다.

-> 클라이언트의 코드 변경 없이도 기능을 확장할 수 있다.

정리

- 모든 설계에 역할과 구현을 분리하자
- 어플리케이션 설계도 공연을 설계할 때처럼 배역만 만들어두고, 배우는 언제든 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자

실무적인 고민

- 인터페이스를 무분별하게 남발하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

### 섹션 2

예제

```

H2 비즈니스 요구사항과 설계
- 회원
    • 회원을 가입하고 조회할 수 있다.
    • 회원은 일반과 VIP 두 가지 등급이 있다.
    • 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
- 주문과 할인 정책
    • 회원은 상품을 주문할 수 있다.
    • 회원 등급에 따라 할인 정책을 적용할 수 있다.
    • 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
    • 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분이다. 그렇다고 이런 정책이 결정될 때 까지 개발 을 무기한 기다릴 수 도 없다. 우리는 앞에서 배운 객체 지향 설계 방법이 있지 않은가!

인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다. 그럼 시작해보자.

*참고* 프로젝트 환경설정을 편리하게 하려고 스프링 부트를 사용한 것이다. 지금은 스프링 없는 순수한 자바로만 개발을 진행한 다는 점을 꼭 기억하자! 스프링 관련은 한참 뒤에 등장한다.
```

> 위의 예제를 직접 프로그래밍 해보면서 인터페이스와 구현체를 나누는 연습을 해보고, 실제 좋은 객체 지향 프로그래밍을 하기 위해 필요한 사항들을 통해 스프링이 어떻게 유연하고 변경에 용이하게 해주는지 확인할 예정입니다.

구현 결과

Member

- `MemberService`가 Member에 대한 생성, 조회를 담당하는 인터페이스 역할을 합니다.
- `MemberServiceImpl`가 `MemberService`의 구현체 역할을 합니다.
- `MemberRepository`가 실제 `Member`를 저장을 담당하는 인터페이스 역할을 합니다.
- `MemoryMemberRepository`가 `MemberRepository`의 실제 구현체 역할을 합니다. (이 후 자체 DB 혹은 외부 시스템 연동 시 새로운 구현체 클래스를 생성하여 사용하면 됩니다.)

Discount

- `DiscountPolicy`가 할인에 대한 인터페이스 역할을 합니다.
- `FixDiscountPolicy`가 할인 정책 중 하나를 구현한 구현체 역할을 합니다. 다른 할인 정책이 생길 경우 다른 구현체 클래스를 통해 구현하면 이전 할인 정책과 동일하게 사용 가능합니다.

Order

- `OrderService`가 상품 구매에 대한 인터페이스 역할을 합니다.
- `OrderServiceImpl`가 상품 구매에 대한 구현체 역할을 합니다.
  1. `MemberService`로부터 Member의 회원 등급을 조회
  2. `DiscountPolicy`로부터 등급에 대한 할인 금액을 확인
  3. 할인된 금액을 통해 Order 생성
  4. Order 반환

각 기능들이 인터페이스와 구현체로 나누어져 있습니다. 이로 인해 `MemberService`가 Member 데이터를 어디에 저장하는지 상관하지 않고 `MemberRepository`의 `save`와 `findById`라는 메서드를 통해 기능을 수행할 수 있습니다. 또한, OrderService는 아직 정해지지 않은 할인 정책에 상관하지 않고 `DiscountPolicy`` 인터페이스를 통해 여러 할인 정책을 상황에 따라 바꿀 수 있게 되었습니다.

하지만, 아직 수정해야하는 부분은 각 인터페이스에 대한 의존과 동시에 구현체에도 의존하고 있으므로 구현체에 대한 변경이 있을 경우 클라이언트 상에서의 변경 또한 불가피하다는 점입니다. 이 후의 강의를 통해 어떻게 수정이 되는지 확인해보도록 하겠습니다.

2월 2일

---

### 섹션 3

> 이전 섹션에서 개발 명세서를 통해 각각의 역할과 구현을 분리하여 개발을 진행했습니다. 이번 섹션에서는 새로운 할인 정책이 생겼을 때 코드 상에서 어떤 변화가 생기는지 확인하고, 객체 지향 원칙을 잘 지키고 있는지, 잘 지키고 있지 않다면 어떻게 변화를 주어야 하는지 알아보도록 하겠습니다.

새로운 할인 정책

- 이전의 할인 정책은 VIP 등급의 고객이 물건을 구매할 경우 상품의 가격에 상관없이 1000원을 할인해주는 형식이었다.
- 새로운 할인 정책은 VIP 등급의 고객이 물건을 구매할 경우 상품의 가격의 **10%**를 할인해주는 형식이다.

-> 이전의 `DiscountPolicy` 역할에 새로운 구현체를 생성해주고 `OrderServiceImpl` 상에서 새로운 구현체로 갈아끼워주면 된다.

변경사항

- 새로운 할인 정책 구현체(`RateDiscountPolicy`)를 생성
- `OrderServiceImpl`에서 `DiscountPolicy` 인터페이스에 대한 구현체를 `RateDiscountPolicy`로 변경

변경사항의 문제점

- 현재 역할과 구현을 충분히 분리해주었다. -> 인터페이스와 구현 객체로 분리
- 하지만, DIP와 OCP를 준수하지 못했다.
- DIP: 위 서비스 상에서 클라이언트 `OrderServiceImpl`는 인터페이스 `DiscountPolicy`에 의존하고 있는 상황이다. 하지만, 인터페이스뿐만 아니라 구현 클래스(`FixDiscountPolicy`, `RateDiscountPolicy`)에도 의존하고 있는 상황이다.
- OCP: 변경에는 닫혀있어야 하지만, 구현 객체의 변경이 생기면서 클라이언트의 코드를 수정해야 하는 상황이 발생했다.

클라이언트 코드에 변경이 생긴 이유

- 기대했던 것은 클라이언트가 인터페이스에만 의존하는 것이었다.
- 하지만, 실질적으로는 구현 객체들에게도 의존을하고 있는 상황
- 그렇다보니, 구현 객체의 변경이 생길 경우 클라이언트 코드에 대한 변경 또한 생기게 되었다.

문제 해결 방법

- 클라이언트가 인터페이스(추상)에만 의존하도록 해야 한다.
- 하지만, 현재 상황에서 구현체를 단순히 지우기만 한다면 `NullPointException`이 발생하개 된다.
- 그러므로, 누군가가 클라이언트가 의존하고 있는 인터페이스에 구현 객체를 대신 생성하고 주입해주어야 한다.

관심사의 분리

- 어플리케이션을 하나의 공연이라고 해보자
- 로미오와 줄리엣 공연을 하게 될 경우, 공연의 배역은 각 배역들이 지정해주는 것이 아니다.
- 즉, 로미오 역할에 디카프리오가 맡게될 경우, 줄리엣의 역할은 디카프리오가 정하는 것이 아니라는 말이다.
- 각 역할에 대한 배역을 정해주는 것은 공연의 기획부에서 하는 일이다!
- 로미오의 역할은 디카프리오가 자신의 스타일대로 구현해주는 것이고, 줄리엣 역할은 줄리엣 역할을 맡은 배우가 구현해주는 것이다. 이러한 배우들을 캐스팅하는 것은 공연의 기획부의 책임인 것이다.
- 기획부는 배우 캐스팅, 배우들은 맡은 역할에 대한 연기를 하는 것처럼 각각은 자신만의 단일 책임만을 가지고 있다.

관심사의 분리 적용

- 현재 클라이언트는 인터페이스를 선언하고 실제 구현 객체와 연결하는 책임 두 개를 가지고 있었다.
- 이 중, 클라이언트는 인터페이스에게만 의존하도록 변경해준다.
- 그리고, 클라이언트에서 의존할 인터페이스에 대한 실제 구현체의 생성과 연결은 다른 무언가(공연의 기획부)가 담당해준다.
- 클라이언트는 인터페이스를 사용만 하고, 구현 객체의 생성 및 연결은 다른 클래스가 담당하도록 해준다.

변경 사항

- 클라이언트인 `MemberService`와 `OrderService`는 현재 의존하고 있는 인터페이스와 구현 객체에서 구현 객체를 지워주고, 생성자를 통해 인터페이스에 할당할 객체들을 누군가로부터 받아올 수 있도록 해준다.
- `AppConfig`라는 클래스를 통해 `MemberService`와 `OrderService`를 생성할 수 있도록 해주고, 각 생성자 상에서 인터페이스의 구현 객체들을 생성해서 넣어준다.

-> `AppConfig`라는 클래스가 인터페이스에 대한 구현 객체 생성 및 연결을 담당하도록 한다.

-> 새로운 할인 정책을 적용하고 싶을 경우 이제는 클라이언트인 `OrderService` 상의 코드를 변경해주는 것이 아닌 AppConfig 내의 코드를 변경하면 된다.

정리

- 다형성을 통해 개발함으로써 인터페이스(추상)와 구현체(구체)의 분리를 통해 새로운 기능을 추가하는데에는 문제가 없었습니다.
- 하지만, 클라이언트가 인터페이스에 의존함과 동시에 구현체에 대해서도 의존하고 있기 때문에 새로운 기능으로 수정할 경우 클라이언트 상의 코드 또한 변경 사항이 생겼습니다.
- 이는 클라이언트 상에서 인터페이스에 대한 구현체의 생성 및 연결에 대한 역할 또한 부여되어 있기 때문이므로, 인터페이스에 대한 구현 객체의 생성 및 연결은 다른 클래스가 담당하도록 해줍니다.
- 클라이언트는 인터페이스에 대해서만 의존을 하고 생성자를 통해 구현 객체를 주입 받을 수 있도록 하고, 다른 클래스 상에서 클라이언트 클래스가 사용할 구현 객체에 대한 관리 및 주입을 해줌으로써 클라이언트는 자신의 역할만 할 수 있는 상태가 되었습니다.

좋은 객체 지향 설계의 5가지 원칙의 적용

- SRP: 클라이언트가 가지고 있던 여러 책임을 다른 클래스에 주게 되면서 자신의 책임만 담당하게 되었습니다.
- DIP: 클라이언트가 인터페이스(추상)에만 의존하고 있습니다. 어떤 구현 객체를 사용하는지 모르는 상태로 자신의 역할만 수행하게 됩니다.
- OCP: 새로운 정책으로 인해 구현 객체의 변경이 생기더라도 클라이언트 상에서는 변경이 일어나지 않습니다.

제어의 역전

- 기존의 프로그램은 스스로 필요한 객체를 생성, 연결, 실행하도록 되어 있다.
- `AppConfig`와 같은 것의 등장으로 인해 객체는 자신의 로직을 실행하는 것에만 집중하게 되었다.
- 인터페이스에 대한 구현 객체의 선택과 같은 프로그램 흐름에 대한 제어는 `AppConfig`가 담당한다.

의존 관계 주입

- 클라이언트가 의존하고 있는 인터페이스는 어떤 구현 객체가 사용될지 모른다.
- 정적인 클래스 의존 관계: 어플리케이션을 실행하지 않아도 판단할 수 있는 의존 관계 (클라이언트와 클라이언트가 의존하는 인터페이스와의 관계)
- 동적인 클래스 의존 관계: 어플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계 (클라이언트와 클라이언트가 의존하는 인터페이스에 주입된 구현 객체의 클래스와의 관계)
- 의존 관계 주입을 사용함으로써 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존 관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

IOC 컨테이너, DI 컨테이너

- 객체를 생성하고 관리하면서 의존관계를 연결시켜주는 것
- 의존관계 주입에 초점을 맞추고 있다.
- 어셈블러, 오브젝트 팩토리 등으로도 불린다.

스프링 코드로 변경

- 스프링 컨테이너가 관리하는 빈으로 선언하고 싶다면 해당 클래스에 `@Configuration`을 선언해주고, 원하는 메서드에 `@Bean`을 선언해준다.
- `@Configuration`을 클래스에 선언해주어야지만 스프링 컨테이너가 `@Bean`이 붙은 메서드들을 빈으로 생성하고 관리해준다고 한다.
- `ApplicationContext applicationContext = AnnotationConfigApplicationContext(AppConfig.class)`, `applicationContext.getBean(name,{클래스명}.class)`를 통해 스프링 컨테이너가 관리하고 있는 클래스를 가져올 수 있다.
- 자세한 내용은 이후에 나온다..

스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라고 한다.
- 이전 `AppConfig` 사용시 직접 객체를 생성하고 DI를 했지만, 이제 스프링 컨테이너를 통해서 사용한다.
- `@Configuration`이 붙은 클래스를 설정 정보로 사용한다. 이 클래스 상에 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 등록된 객체를 스프링 빈이라고 한다.
- 스프링 빈은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- 스프링 컨테이너에서 getBean을 통해 스프링 빈을 찾을 수 있다.

정리

- 관심사의 분리를 통해 클라이언트가 인터페이스에만 의존하도록 변경해주었다.
- 클라이언트가 사용할 구현 객체에 대한 주입을 다른 클래스(설정 정보)에서 담당해준다.
- 이처럼, 사용할 객체에 대한 흐름을 프로그래머가 제어하는 것이 아닌 다른 것에 넘겨주는 것을 제어의 역전이라고 한다.
- 스프링에서는 스프링 컨테이너가 객체들을 생성, 관리, DI 해주는 역할을 맡고 있다.

이제 스프링 컨테이너를 통해 어떤 이점을 가질 수 있는지 알아보도록 하겠습니다.

2월 3일

---

### 섹션 4

스프링 컨테이너

- `ApplicationContext` 인터페이스가 스프링 컨테이너이다.
- 스프링 컨테이너는 XML, 어노테이션 기반의 자바 설정 클래스, 커스텀 등을 통해 만들 수 있다.
- 이전의 AppConfig 클래스를 사용한 방식이 자바 설정 클래스로 스프링 컨테이너를 만든 것이다.
- `AnnotationConfigApplicationContext`가 `ApplicationContext`에 대한 구현체이고 생성자에 구성 정보 클래스를 넣어주면 스프링 컨테이너를 만들 수 있다.

스프링 컨테이너 생성 과정

- `new AnnotationConfigApplicationContext(AppConfig.class)` 를 통해 AppConfig의 설정 정보 기반 스프링 컨텍스트에 대한 구현체를 만들 수 있다.
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 기반으로 스프링 빈을 등록한다. (빈 이름은 메서드 이름으로 등록되고, 직접 부여할 수도 있다. 빈의 이름은 항상 다른 이름을 부여해주어야 한다. )
- 스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI)해줍니다.

-> 스프링 컨테이너는 XML이나 자바 설정 클래스를 기반으로 스프링 빈을 등록하고 의존 관계를 주입해준다.

빈 조회

- `AnnotationConfigApplicationContext` 객체를 활용합니다.
- `ac.getBean(빈이름, 타입)`, `ac.getBean(타입)`: 인자 정보를 가지는 빈 조회
- 조회 대상이 없을 경우 `NoSuchBeanDefinitionException` 오류 발생
- 타입으로 조회 시 같은 타입의 스프링 빈이 둘 이상이면 `NoUniqueBeanDefinitionException` 오류 발생 (빈 이름으로 조회하면 된다)
- `ac.getBeansOfType()`: 해당 타입의 빈들을 모두 조회
- 부모 타입으로 조회하면 자식 타입도 함께 조회된다. (모든 클래스의 조상인 object 클래스를 조회하면 모든 스프링 빈이 출력된다.)

BeanFactory

- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈의 관리와 조회하는 역할을 담당

ApplicationContext

- `BeanFactory`를 상속받아서 제공한다
- 빈 등록, 조회 이외에 다른 많은 일들을 한다.
- MessageSource: 메시지 소스를 활용한 국제화 기능
- EnvironmentCapable: 환경 변수 설정 관련 기능
- ApplicationEventPublisher: 어플리케이션의 이벤트 발행, 구독 모델 지원
- ResourceLoader: 파일, 클래스패스, 외부 리소스 조회 지원

스프링 컨테이너 설정 정보 제공 방식

- XML, 어노테이션 기반 자바 클래스, 커스텀 방법이 있다.
- `ApplicationContext`를 구현한 `AnnotationConfigApplicationContext`는 자바 클래스 기반 설정 정보를 읽을 수 있다.
- `ApplicationContext`를 구현한 `GenericXmlApplicationContext`는 XML 기반 설정 정보를 읽을 수 있다.
- 스프링 부트가 사용되면서 XML 기반의 설정은 잘 사용하지 않는다. 하지만, 아직 많은 레거시 프로젝트에서 XML이 사용되고 있고, XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있다.

BeanDefinition

- 스프링은 XML, 자바 클래스 기반, Groovy 등 다양한 설정 형식을 제공한다.
- 다양한 설정 방법, 커스텀 설정 방법을 제공할 수 있는 이유는 `BeanDefinition`이라는 추상화 덕분이다.
- 이 또한 역할과 구현을 나누어줌으로써 스프링 컨테이너는 설정 형식에 상관없이 `BeanDefinition`만을 통해 빈을 등록 및 의존 관계 주입을 해줄 수 있다.
- `BeanDefinition`은 빈의 설정 메타정보이다.
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
- 각각의 스프링 컨테이너 구현체들은 자신의 설정 정보를 읽을 수 있는 Reader들이 존재한다.
  - `GenericXmlApplicationContext`: `XmlBeanDefinitionReader`
  - `AnnotationConfigApplicationContext`: `AnnotatedBeanDefinitionReader`
- 각각의 Reader를 통해 설정 정보를 읽고 이를 통해 `BeanDefinition`을 생성한다.
- 새로운 형식의 설정 정보를 추가하고 싶다면, Reader를 만들어 `BeanDefinition`을 반환하도록 해주면 된다.
- `BeanDefinition`을 직접 생성해서 스프링 컨테이너에 전달할 수 있다.

정리

- 스프링 컨테이너는 XML, 어노테이션 기반 자바 클래스 등 각각의 구현체를 통해 빈을 등록할 수 있다.
- 등록된 빈은 스프링 컨테이너 구현체의 `getBean()` 메서드를 통해 가능하다.
- `ApplicationContext`의 상위 인터페이스인 `BeanFactory`가 빈의 등록이나 조회와 같은 역할을 한다.
- `ApplicationContext`는 스프링 빈 관리 이외의 여러 기능들을 수행한다.
- 스프링 컨테이너는 전달받은 `BeanDefinition`이라는 설정 메타정보 객체를 통해 빈을 등록하기 때문에 다양한 설정 형식을 가질 수 있다.

2월 3일

---

### 섹션 5

웹 어플리케이션과 싱글톤

- 웹 어플리케이션은 보통 여러 고객들의 요청을 동시에 처리한다.
- 스프링이 없는 어플리케이션 상에서 요청이 들어올 때마다 새로운 객체를 생성하고 주입해서 사용하는 것은 굉장한 메모리 낭비이다.
- 이러한 낭비를 줄일 수 있는 방법은 객체를 한 개만 생성하고 이를 공유하도록 설계하는 것이다.

싱글톤 패턴

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- `static` 영역에 한 개의 인스턴스를 생성한 뒤 `getInstance()` 메서드를 통해서 인스턴스를 반환 받을 수 있도록 해준다.
- `private` 생성자를 작성하여 외부에서 새로운 객체를 만들지 못하도록 막는다.

```java
// 싱글톤 패턴을 구현하는 방법 중 하나이다.
public class SingletonService {
  private static final SingletonService instance = new SingletonService();

  public SingletonService getInstance(){
    return instance;
  }

  private SingletonService(){}
}
```

싱글톤 패턴 문제점

- 싱글톤 패턴을 사용하면 고객의 요청이 올 때마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만, 다음과 같은 문제점들이 있다.
- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
- 의존 관계상 클라이언트가 구체 클래스에 의존하게 되면서 DIP를 위반한다.
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
- 테스트하기 어렵다
- 내부 속성을 변경하거나 초기화하기 어렵다.
- `private` 생성자로 자식 클래스를 만들기 어렵다.
- 유연성이 떨어진다.
- 위와 같은 문제점들로 인해 안티패턴으로 불리기도 한다.

싱글톤 컨테이너

- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 한 개만 생성하여 관린한다.
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너가 싱글톤 컨테이너 역할을 한다. 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
- 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴을 위한 추가 코드 작성, private 생성자 작성, DIP와 OCP 성립 등 싱글톤 패턴의 문제점을 해결할 수 있다.

-> 스프링 컨테이너 덕분에 고객의 요청이 들어올 때 마다 객체를 생성하는 것이 아니라 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.
-> 스프링 컨테이너는 싱글톤 방식만 지원하지는 않는다. 뒤의 빈 스코프에서 더 자세히 살펴보도록 하겠습니다.

싱글톤 방식의 주의점

- 객체를 하나만 생성해서 공유하기 때문에 싱글톤 객체는 상태 유지하게 설계되면 안된다.
- 특정 클라이언트에 의존적인 필드가 있으면 안된다.
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
- 가급적 읽기만 가능해야 한다.
- 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

-> 무상태로 설계해야 한다.

@Congiruation

```java
 @Configuration
 public class AppConfig {
    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
    @Bean
    public OrderService orderService() {
         return new OrderServiceImpl(
                 memberRepository(),
                 discountPolicy());
    }
    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    ...
}
```

- 위 코드를 살펴보면 `orderService`, `memberService` 빈을 등록하기 위해서는 `memoryMemberRepository`를 두 번 더 등록하는 것처럼 보인다.
- 하지만, 실질적으로는 `memberRepository` 인스턴스와 모두 같은 인스턴스가 공유된 것을 알 수 있다.
- 스프링 컨테이너는 싱글톤 레지스트리로 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
- `@Configuration`을 선언한 `AppConfig` 또한 스프링 빈으로 등록되게 되는데, 이 때 `AppConfig`의 클래스 정보를 확인해보면 xxxCGLIB가 붙으면서 실제 클래스명과 다른 것을 알 수 있다.
- 스프링이 `@Configuration`이 선언된 클래스를 CGLIB라는 바이트코드 조작 라이브러리를 활용해 상속받은 임의의 다른 클래스를 만들고 이를 스프링 빈으로 등록한 것을 알 수 있다. 그 임의의 다른 클래스가 싱글톤이 보장되도록 해준다.
- `@Bean`이 붙은 메서드마다 아직 스프링 빈으로 등록되지 않았다면 스프링 빈으로 등록해주고 스프링 빈이 이미 등록되어 있다면 등록된 스프링 빈을 반환해주는 식으로 동작하면서, 중복적으로 등록될 수 있는 빈들을 한 번만 등록되도록 보장해주고 있는 것이다.
- `@Configuration`을 적용하지 않는다면 `AppConfig`는 조작되지 않은 순수 클래스 상태로 빈에 등록되게 되고, 등록된 빈은 싱글톤을 보장받지 못하게 된다.

정리

- 스프링 컨테이너는 싱글톤 컨테이너 역할을 함으로써 싱글톤 패턴의 문제(추가적인 코드 작성, private 생성자, DIP OCP 위반)를 해결하면서 등록된 빈을 싱글톤으로 관리한다. (싱글톤 레지스트리)
- 싱글톤으로 생성된 객체는 stateless하게 설계해야 한다.
- 스프링 컨테이너는 CGLIB 라이브러리를 통해 바이트코드를 조작하여 `@Configuration`이 선언된 클래스를 상속받은 새로운 클래스를 선언하고 이 클래스가 싱글톤이 보장되도록 해준다.
- `@Configuration` 없이 `@Bean`만 선언되면 싱글톤을 보장받지 못한다.

2월 4일

---

### 섹션 6

정리

- 지금까지 `@Bean`이나 `<Bean />`을 통해 설정 정보에서 직접 등록할 빈을 나열했다. 이러한 등록이 반복되는 것은 귀찮을 일이다.
- 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈이 등록되도록 하는 컴포넌트 스캔과 의존관계 자동으로 주입해주는 기능을 제공해준다.

컴포넌트 스캔

```java
@Configuration
@ComponentScan
public class AutoAppConfig {
}
```

- `@ComponentScan` 어노테이션을 선언하면 컴포넌트 스캔을 할 수 있다.
- 컴포넌트 스캔은 `@Component` 어노테이션이 붙은 클래스를 스캔해 스프링 빈으로 등록한다.
- 스프링 등록을 하고 싶은 클래스의 경우 `@Component`를 선언해주면 컴포넌트 스캔에 의해 스프링 빈으로 등록된다.

```java
 @Component
 public class MemoryMemberRepository implements MemberRepository {}

```

- 스프링 빈으로 등록된 클래스의 경우 의존관계 또한 명시해주어야 한다. 이전과 같은 경우 직접 작성해서 의존관계를 명시해주었지만, 이제는 설정 정보를 작성하지 않기 때문에 의존 관계 주입 또한 스프링 빈으로 등록할 클래스 상에 명시해주어야 한다.
- `@Autowired` 를 통해 의존관계를 자동으로 주입해줄 수 있다.
- 여러 개의 의존 관계도 한 번에 주입 받을 수 있다.

```java
@Component
public class OrderServiceImpl implements OrderService {
  private final MemberRepository memberRepository;
  private final DiscountPolicy discountPolicy;

  @Autowired
  public OrderServiceImpl(MemberRepository memberRepository DiscountPolicy discountPolicy) {
      this.memberRepository = memberRepository;
      this.discountPolicy = discountPolicy;
  }
}
```

정리

- 컴포넌트 스캔은 `@Component` 어노테이션이 선언된 클래스를 모두 스프링 빈으로 등록해준다.
- 스프링 빈의 기본 이름은 클래스명을 사용하지만, 맨 앞글자만 소문자로 변경된다. (직접 설정도 가능)
- 스프링 빈의 의존 관계 주입은 `@Autowired`를 선언하면 스프링 컨테이너가 자동으로 주입해준다. 기본 조회 전략은 같은 타입의 빈을 주입하는 것이다.

탐색 위치 설정

- `basePackages = {"hello.core", "hello.service"}` : 스캔 시작 위치를 지정할 수 있다.
- `basePackageClasses` = 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
- 지정하지 않을 경우 `@ComponentScan`가 붙은 설정 정보 패키지가 시작 위치가 된다.

-> 패키지 지정 위치를 지정하기 보다는 설정 정보 클래스를 프로젝트 최상단에 둠으로써 모든 프로젝트의 컴포넌트를 찾을 수 있도록 한다.
-> 스프링 부트의 대표 시작 정보인 `@SpringBootApplication` 내부에 `@ComponentScan`이 들어있다. 그러므로 이를 프로젝트 루트 위치에 두는 것이 좋다.

컴포넌트 스캔 기본 대상

- `@Component`: 컴포넌트 스캔에 사용
- `@Controller`: 스프링 MVC 컨트롤러로 인식
- `@Service`: 비즈니스 로직임을 인식
- `@Repository`: 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- `@Configuration`: 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 처리해준다.
- `@Component`를 제외한 어노테이션 내부에 `@Component`가 선언된 것을 확인할 수 있다.
- 어노테이션은 상속 관계는 없다. 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어 기능이 아니라 스프링이 지원하는 기능이다.

필터

- includeFilters: 컴포넌트 스캔 대상을 추가로 지정
- excludeFilters: 컴포넌트 스캔에서 제외할 대상을 지정

FilterType 옵션

- ANNOTATION: 어노테이션을 인식해서 동작
- ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작
- ASPECTJ: AspectJ 패턴 사용
- REGEX: 정규 표현식
- CUSTOM: TypeFilter 라는 인터페이스를 구현해서 처리

중복 등록

- 자동으로 등록된 두 빈이 이름이 같아 충돌할 경우 `ConflictingBeanDefinitionException` 예외가 발생한다.
- 수등으로 등록된 빈과 자동으로 등록된 빈이 충돌할 경우
  - 예전: 수동 등록된 빈이 우선권을 갖는다.
  - 현재: 스프링 부트에서는 충돌 시 오류가 발생하도록 기본값이 변경되었다. 물론 설정을 변경할 수 있다.

정리

- 컴포넌트 스캔을 통해 설정 정보를 직접 작성하지 않아도 자동으로 스프링 빈을 등록할 수 있다.
- `@Component` 어노테이션이 선언된 클래스가 스프링 빈으로 등록된다.
- 스프링 빈 등록 시 필요한 의존관계 주입은 `@Autowired`를 선언하면 자동으로 주입해준다.
- 컴포넌트 스캔의 탐색 위치를 설정해줄 수 있다. 권장하는 방법은 컴포넌트 스캔 설정 파일을 프로젝트 루트에 위치시키는 것이다.
- 컴포넌트 스캔에 포함할 대상과 제외할 대상을 선언할 수도 있습니다.
- 이름이 중복된 빈이 있을 경우 스프링 부트는 오류를 반환합니다.

2월 4일

---

### 섹션 7

의존관계 주입 방법

- 생성자 주입
- 수정자 주입(setter)
- 필드 주입
- 일반 메서드 주입

생성자 주입

- 생성자를 통해 의존 관계를 주입 받는 방법
- 생성자 호출시점에 1번만 호출되는 것이 보장된다.
- 불변, 필수 의존 관계에 사용
- 생성자가 1개라면 `@Autowired` 생략 가능

수정자 주입(setter)

- 필드 값을 변경하는 수정 메서드를 통해 의존 관계를 주입하는 방법
- 선택, 변경 가능성이 있는 의존관계에 사용
- 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
- `@Autowired`의 기본 동작은 주입할 대상이 없다면 오류가 발생한다. 오류가 발생하지 않도록 하려면 `@Autowired(required=false)`를 해주어야 한다.

필드 주입

- 필드에 바로 주입하는 방법이다.
- 코드가 간결해지지만 외부에서 변경이 불가능해서 테스트하기 힘들다
- DI 프레임워크가 없다면 아무것도 할 수 없다.
- 테스트 코드 작성 시, `@Configuration`을 통해 설정하려는 목적일 때만 사용하자

> `@Bean`에서 파라미터에 의존관계는 자동적으로 주입된다.

```java
@Bean
BeanService beanService(DependentRepository dependentRepository){
  return new BeanService(dependentRepository);
}
```

일반 메서드 주입

- 일반 메서드를 통해 주입 받을 수 있다.
- 한 번에 여러 필드를 주입 받을 수 있다.
- 일반적으로 잘 사용하지는 않는다.

자동 주입 옵션 처리

- `@Autowired(required=false)`: 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출이 안됨
- `org.springframework.lang.@Nullable`: 자동 주입할 대상이 없다면 null이 입력된다.
- `Optional<>`: 자동 주입할 대상이 없다면 Optional.empty 가 입력된다.
- `@Nullable`과 `Optional`은 스프링 전체적으로 사용이 된다. 생성자 자동 주입에서 특정 필드에만 사용하도록 할 수도 있다.

생성자 주입을 선택해야 하는 이유

- 과거 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 DI 프레임워크에서 대부분 생성자 주입을 권장한다.
- 불변
  - 대부분의 의존관계 주입은 한 번 일어나면 변경될 일이 없다.
  - 수정자 주입 시 `setXxx` 메서드를 public으로 선언해두어야 한다.
  - 생성자 메서드는 객체 생성 시 1번만 호출되는 것이 보장되기 때문에 불변하게 설계할 수 있다.
- 누락
  - `@Autowired`는 순수 자바코드일 경우 의존관계 주입이 누락되면 `NullPointException`으로 컴파일 단계에서는 오류를 포착하기 힘들다
  - 생성자 주입을 사용하면 주입 데이터가 누락 될 경우 컴파일 오류가 발생한다. (코드 작성 단계에서 오류 파악이 가능하다.)

`setXxx` 주입

````java
@Component
class AutoWiredService1 {
  DependentService1 dependentService1;
  DependentService2 dependentService2;

  void setDependentService1(DependentService1 dependentService1){
    this.dependentService1 = dependentService1;
  }

  void setDependentService1(DependentService2 dependentService2){
    this.dependentService2 = dependentService2;
  }
}

생성자 주입

```java
@Component
class AutoWiredService2 {
  DependentService1 dependentService1;
  DependentService2 dependentService2;

  public AutoWiredService2(DependentService1 dependentService1,DependentService2 dependentService2){
    this.dependentService1 = dependentService1;
    this.dependentService2 = dependentService2;
  }
}
````

```java
@Test
void test(){
  AutoWiredService autoWiredService = new AutoWiredService();
  autoWiredService.doSth();
  ...
}
```

- 수정자를 통해 의존관계를 주입 받았다면 위 테스트코드 상에 아무 문제가 없다는 것을 알 수 있다.(하지만, 의존관계를 주입받지 않았기 때문에 오류가 발생한다.)
- 생성자를 통해 의존관계를 주입 받았다면 위 테스트코드 작성 시점에 의존관계가 주입되지 않았다는 것을 바로 파악할 수 있다.

- `final` 키워드
  - 생성자 주입을 사용하면 final 키워드를 사용하여 생성자 상에서 설정되지 않은 의존관계가 있을 경우 컴파일 시점에 오류를 막아줄 수 있다.

정리

- 의존관계를 주입 받을 수 있는 방법은 다양하다. 하지만, 생성자 주입 방식을 사용하는 것이 프레임워크에 의존하지 않고 순수 자바 언어의 특징을 잘 살리는 방법이다.
- 필수 값이 아닌 경우는 수정자 주입 방식으로 사용한다.

롬복

- 생서자와 관련된 코드를 작성하는 것은 귀찮은 일이다.
- 이를 롬복을 통해 해소할 수 있다.
- 롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 final이 선언된 필드가 모두 포함된 생성자를 자동으로 만들어준다.

조회된 빈이 두 개 이상일 경우

- `@Autowired`는 타입으로 조회한다. 선택된 빈이 2개 이상일 경우 문제가 발생한다.
- `@Autowired` 필드 명 매칭
  - `@Autowired`는 타입 매칭을 시도하고, 2개 이상이 조회될 경우 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
- `@Qualifier`
  - 추가 구분자를 붙여 구분하는 방식(빈 이름이 변경되는 것은 아니다)
  - 해당 구분자가 선언된 빈을 찾지 못한다면 주어진 구분자명을 이름으로 가진 빈을 추가로 찾는다.
- `@Primary`
  - 조회된 빈이 2개 이상일 경우 우선권을 가지게 해준다.
- `@Primary`와 `@Qualifier` 둘 다 선언되었을 경우 `@Qualifier`가 우선권이 높다.
- 어노테이션으로 구분하기
  - 위의 방식들은 컴파일시 타입 체크가 불가능하다.
  - 구분짓고자 하는 내용을 `@Qualifier`로 선언한 다음 이를 통해 어노테이션을 만들어 사용하면 빈을 구분하면서 타입체크 또한 할 수 있다.

조회한 빈이 모두 필요할 경우

- `Map<String, 클래스명>` : Map 키에 빈 이름, 밸류에 클래스 타입으로 조회된 모든 빈을 담아준다.
- `List<클래스명>`: 클래스 타입으로 조회된 모든 빈을 담아준다.
- 위 두 가지 방법으로 의존관계를 주입 받을 경우 조회된 모든 빈들을 조회해볼 수 있다.

```java
@Test
void findAllBean(){
    ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class);
    DiscountService discountService = ac.getBean(DiscountService.class);
    Member user1 = new Member(1L, "user1", Grade.VIP);

    int discount = discountService.discount(user1, 20000, "rateDiscountPolicy");

    Assertions.assertThat(discount).isEqualTo(2000);
}

@RequiredArgsConstructor
static class DiscountService{
    final Map<String, DiscountPolicy> policyMap;
    final List<DiscountPolicy> discountPolicies;

    public int discount(Member member, int price, String discountCode){
        DiscountPolicy discountPolicy = policyMap.get(discountCode);
        int discount = discountPolicy.discount(member, price);

        return discount;
    }
}
```

정리

- 의존 관계 주입 중에서는 생성자 주입을 사용하는 것이 프레임워크에 의존하는 것이 아닌 순수 자바 언어의 특징을 살리는 방법이다.
- 수정자 주입을 통해 변경될 수 있는 의존관계와 같은 경우, 옵션 설정을 통해 해당 빈이 존재하지 않을 경우 진행 방식을 결정할 수 있다. (`@Nullable`, `Optional`)
- 롬복을 사용하면 코드 상에 귀찮은 부분을 많이 해소할 수 있다.
- 조회된 빈이 두 개 이상일 경우 `@Qualifier`, `@Primary`를 사용해 특정 빈을 지정해줄 수 있다. (어노테이션을 만들 경우 타입 체크를 통해 컴파일 단계에서 오류를 잡을 수 있다.)
- 여러 개의 빈을 조회할 수도 있다.(`Map`, `List`)
- 되도록이면 자동 빈 등록을 사용하되, 광범위하게 영향을 미치거나 로직 중 다형성을 적극 활용할 경우 수동으로 빈을 등록하면 더 편리하게 개발할 수 있을 것이다.

2월 4일

---

### 섹션 8

빈 생명주기

- 데이터 커넥션 풀이나 소켓처럼 어플리케이션 시작 시점에 필요한 연결을 미리 해두고 어플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행할 경우가 있다.
- 이러한 어느정도의 설정이 필요한 객체를 만들 때, 생성자를 통해서가 아닌 수정자 등을 통해 연결에 필요한 설정을 하고 연결을 시작하는 경우가 있다.
- 스프링 빈은 객체를 모두 생성한 다음 의존관계를 주입해주는 라이프사이클을 가진다.
- 그러므로 초기화에 필요한 작업은 의존관계 주입이 끝난 다음 호출해야 한다.
- 스프링은 콜백 메서드를 통해 의존관계 주입이 끝난 시점과 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 제공해준다.

-> 스프링빈의 이벤트 라이프 사이클: 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

빈 생명주기 콜백

- 인터페이스(`InitializingBean`, `DisposableBean`)
  - 각 인터페이스를 선언하여 초기화 콜백과 소멸 콜백을 작성할 수 있다.
  - 스프링 전용 인터페이스로, 스크링 프레임워크에 의존하게 된다.
  - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  - 외부 라이브러리에 적용할 수 없다.
- 설정 정보에 초기화 메서드, 종료 메서드 이름 지정
  - `@Bean(initMethod="init", destroyMethod="close")`
  - 초기화, 소멸 메서드의 이름을 지정해줄 수 있다.
  - 스프링 빈이 스프링에 의존하지 않는다.
  - 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
  - 소멸 메서드는 이름이 대부분 close, shutdown 등 이름이 정해져 있어서 소멸 메서드 명을 따로 정해주지 않아도 자동으로 추론해준다.
- `@PostConstruct`, `@PreDestroy` 어노테이션 지원
  - 원하는 메서드에 선언해주면 초기화, 소멸 시 호출된다.
  - 가장 권장하는 방법이다.
  - 스프링 종속적인 기술이 아니라 JSR-250라는 자바 표준이므로 다른 컨테이너에서도 잘 동작한다.
  - 컴포넌트 스캔과 잘 어울린다.
  - 외부 라이브러리에는 적용할 수 없다.

정리

- 빈 생명 주기: 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> ... -> 소멸 콜백 -> 스프링 종료
- `@PostConstruct`, `@PreDestroy` 어노테이션을 통해 초기화, 소멸 메서드를 지정할 수 있다.
- 외부 라이브러리에 대한 초기화, 소멸 설정을 할 경우 `@Bean`의 `initMethod`, `destroyMethod`를 사용하자.

2월 5일

---

### 섹션 10

빈 스코프

- 빈이 존재하는 범위를 뜻한다.
- 스프링이 지원하는 빈 스코프
  - 싱글톤: 기본 스코프로 스프링 컨테이너의 시작에서부터 종료까지 유지되는 가장 넓은 범위이다.
  - 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 주입까지만 관여하고 더는 관리하지 않는다.
  - 웹 관련 스코프: 웹 요청, 세선, 서블릿 컨텍스트에 따라 유지되는 스코프이다.

프로토타입

```java
@Scope("prototype")
@Component
public class PrototypeBean{}

@Configuration
public class AppConfig(){
  public PrototypeBean prototypeBean(){
    return new PrototypeBean();
  }
}
```

- 싱글톤과 다르게 프로토타입 빈을 조회할 경우 항상 새로운 빈을 생성해 반환한다.
- 스프링 컨테이너 생성 이후 바로 생성되는 것이 아니라 프로토타입 빈을 조회하는 시점에 생성된다.
- 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입, 초기화(`@PostConstruct`)만 처리해준다.
- 이 후의 생명주기는 스프링 컨테이너에서 책임지지 않는다.
- 종료메서드는 직접 호출하지 않는 이상 호출되지 않는다.

싱글톤 빈과 프로토타입 빈을 함께 사용할 경우 문제점

- 싱글톤 빈 내부에 프로토타입 빈을 주입 받아서 사용하는 경우 문제가 된다.
- 싱글톤 빈은 스프링 컨테이너 생성 이후 바로 생성 및 의존관계 주입이 이루어지게 되는데, 프로토타입 빈이 해당 시점에 생성되어 의존관계로 주입되게 된다.
- 그렇기 때문에 프로토타입 빈이 원하는 시점마다 새롭게 생성되는 것이 아니라 처음에 생성된 프로토타입 빈을 계속해서 사용하게 되므로, 의도와는 다르게 사용될 수 있다.

해결 방법

- 프로토타입 빈을 사용할 때마다 스프링 컨테이너에 요청하는 것
  - 의존관계를 외부에서 주입 받는 것이 아니라 직접 필요한 의존관계를 찾는 것을 DL(Dependency Lookup) 의존관계 조회(탐색)이라고 한다.
  - 스프링에 종속적인 코드가 된다.
- `ObjectFactory`, `ObjectProvider`

  - 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공해준다.
  - 과거에는 `ObjectFactory`를 사용했고 편의 기능이 추가된 `ObjectProvider`가 만들어졌다.

  ```java
  @Autowired
  private ObjectProvider<프로토타입빈> prototypeBeanProvider;

  public int logic(){
    PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
    ...
  }
  ```

  - getObejct()를 통해 필요할 때 새로운 프로토타입 빈을 생성할 수 있다.
  - 스프링 컨테이너를 통해 해당 빈을 찾아서 반환해준다.
  - ObjectFactory: 기능이 단순하고 별도의 라이브러리가 빌요 없다. 스프링에 의존한다.
  - ObjectProvider: ObjectFactory 상속, 옵션, 스트림 처리 등 편의 기능이 많고 별도의 라이브러리가 필요 없다. 스프링에 의존한다.

JSR-330 Provider

```java
//build.gradle

dependencies{
  implementation group: 'jakarta.inject', name: 'jakarta.inject-api', version: '2.0.1'
}
```

```java
public interface Provider<T> {
    T get();
}
```

- `provider.get()` 을 통해 항상 새로운 프로토타입 빈을 생성해 사용할 수 있다.
- 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
- 별도의 라이브러리를 설치해야하긴 한다.
- 자바 표준이므로 다른 컨테이너에서도 사용할 수 있다.
- `@Lookup` 어노테이션을 통해서도 새로운 프로토타입을 받을 수 있다.

웹 스코프

- 웹 환경에서만 동작한다.
- 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다 -> 종료 메서드가 호출된다.
- request: HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
- session: HTTP Session과 동일한 생명주기를 가지는 스코프
- application: 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프
- websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

스프링 어플리케이션에서 웹 스코프 사용 시 주의할 점

- 스프링에서 웹 스코프를 사용할 경우 주의해야 할 점은 아직 생성되지 않은 웹 스코프를 의존관계를 가진 빈이 있을 경우 스프링 어플리케이션 실행 시점에 웹 스코프의 빈은 아직 생성되지 않은 상태로 의존관계로 주입될 수 없는 상태이기 때문에 스프링 어플리케이션을 실행할 수 없다.
- 그렇기 때문에 프로토타입과 같이 원하는 시점에 DL을 통해 빈을 원하는 시점에 반환 받거나 프록시를 사용해야 한다.

  - `ObjectProvider`, `Provider`
    - 프로토타입 빈을 주입 받는 것처럼 원하는 시점에 빈을 생성 및 주입 받아 사용할 수 있도록 해준다.
  - 프록시
    - `@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)` 로 선언해준다.
    - 위와 같이 선언 시 웹 스코프 빈의 가짜 프록시 클래스를 만들어 HTTP request와 상관 없이 가짜 프록시 클래스를 주입해 둘 수 있다.
    - 가짜 프록시 클래스는 이전 싱글톤 보장을 위해 바이트코드를 조작하는 CGLIB에 의해 만들어진다.
    - 가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 있다.
    - 가짜 프록시 객체는 원본 클래스를 상속 받아 만들어졌기 때문에 클라이언트 입장에서는 사실 원본인지 아닌지 모른다.(다형성)

- 빈 스코프는 싱글톤, 프로토타입 웹이 있다.
- 프로토타입 빈은 스프링 컨테이너에 요청이 들어올 때 생성되어 주입되고, 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입, 초기화까지만 처리한다.
- 싱글톤 빈의 의존관계 중 프로토타입 빈을 사용할 경우 `ObjectProvider`, `Provider`를 통해 원하는 시점에 프로토타입 빈을 생성해 사용할 수 있도록 한다.
- 웹 스코프는 웹 환경에서 동작하고 스프링컨테이너가 전체 생명주기를 관리해준다.
- 웹 스코프 빈에 의존관계를 가진 클래스가 있을 경우 웹 어플리케이션 구동 시 아직 웹 스코프 빈이 생성되지 않은 시점이기 때문에 오류가 발생한다. 그러므로 웹 스코프 빈을 원하는 시점에 주입을 받거나, 프록시를 통해 가짜 프록시 객체를 우선 주입해 두는 식으로 해결할 수 있다.

2월 5일

---
