## 배운 내용

### 섹션 1

스프링 프레임워크란?

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

스프링 부트

- 스프링을 편리하게 사용할 수 있도록 해주는 것
- 단독으로 실행할 수 있는 스프링 어플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 어떠한 라이브러리를 사용하기 위해 종속된 다른 라이브러리들까지 설치해야 되는 경우 starter 라이브러리로 한 번에 모두 설치할 수 있도록 도와준다
- 스프링과 외부 라이브러리 버전 호환을 자동으로 구성해준다.
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 설정을 해주고 바꾸고 싶은 부분은 따로 바꿀 수 있다.

스프링의 핵심 컨셉

- 스프링은 자바 언어 기반 프레임워크이다
- 자바의 가장 큰 핵심은 **"객체 지향 언어"** 라는 점이다
- 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내는 프레임워크이다.

즉, 스프링은 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크이다.

> 과거 EJB를 사용하면 EJB를 상속받아 사용하는 과정에서 EJB에 의존적으로 개발을 하게 되었다. -> 객체지향이 가진 장점을 다 잃어버리게 되었다. 그래서 순수한 자바, 객체 지향 프로그래밍으로 돌아가고자 나온 것이 POJO 등이 있는 것이다. 스프링의 DI 컨테이너 등이 객체 지향적으로 개발이 가능하도록 해주고 있다.

그렇다면 **좋은 객체 지향 프로그래밍**이란 무엇인가?

객체 지향 프로그래밍은 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받으며, 데이터를 처리할 수 있다. 객체 지향 프로그래밍은 프로그램을 **유연하고 변경이 용이하게** 만들어준다. 이는 객체 지향의 특징 중 하나인 다형성으로 설명할 수 있다.

다형성

- 세상을 역할(인터페이스)와 구현(구현체)로 나눌 수 있다.
- 운전자의 역할, 자동차의 역할이 있다면, 운전자의 구현체는 나 혹은 다른 사람이 되고 자동차의 구현체는 k3, 아반떼, 테슬라 등이 될 수 있다.
- 운전자가 자동차를 k3에서 아반떼로 바꾸어도 운전자에게는 영향을 주지 않는다.
- 운전자는 자동차의 내부 구조에 대해서 알지 못해도 상관 없다.
- 운전자에게 영향을 주지 않아도 자동차의 새로운 기능을 제공해줄 수 있다.

역할과 구현의 분리

- 역할과 구현으로 구분하면 단순해지고, 유연해지며 변경도 편리하다.
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 자바 언어의 다형성 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 구현 객체

다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

다형성의 한계

- 역할 자체가 변경된다면, 클라이언트 서버 모두 큰 변경이 발생한다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

스프링과 객체 지향

- 다형성이 가장 중요하다!
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전, 의존 관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원해준다.

좋은 객체 지향 설게의 5가지 원칙 (SOLID)

- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존관계 역전 원칙

다형성과 5원칙 위배

- OCP 위배

다형성을 통해 인터페이스와 구현체를 분리하여 개발을 진행할 수 있다. `MemberRepository` 인터페이스를 구현한 클래스 `MemoryMemberRepository`와 `JdbcMemberRepository가`` 있을 때, 앞의 클래스를 사용하다가 뒤의 클래스를 사용하기 위해서는 클라이언트의 코드를 바꿔야 되므로 OCP를 위배하게 된다.

```java
MemberRepository memberRepository = new MemoryMemberRepository();
// MemoryMemberRepository->JdbcMemberRepository로 클래스 변경
MemberRepository memberRepository = new JdbcMemberRepository();
```

- DIP 위배

위의 예시를 살펴보면 MemberRepository라는 인터페이스에 대해 의존하고 있지만, 이를 구현한 클래스인 `MemoryMemberRepository`와 `JdbcMemberRepository`에게도 의존하고 있는 형태로 존재하고 있다. 이는 DIP를 위배하게 된다.

-> 다형성만으로는 좋은 객체 지향(유연하고 변경이 용이한) 프로그래밍을 할 수 없다.

정리

- 객체 지향의 핵심은 다형성이다.
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성만으로는 인터페이스에만 의존하는 것이 아닌 구현 클래스에도 의존하게 된다.

더 쉽게 부품 갈아 끼우듯이 개발하기 위해서는 무엇인가 더 필요하다 -> **스프링!**

스프링의 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.

- **DI(Dependency Injection)**: 의존관계, 의존성 주입
- **DI 컨테이너** 제공: DI 컨테이너 내부에서 객체들을 저장하고 의존 관계를 연결해준다.

-> 클라이언트의 코드 변경 없이도 기능을 확장할 수 있다.

정리

- 모든 설계에 역할과 구현을 분리하자
- 어플리케이션 설계도 공연을 설계할 때처럼 배역만 만들어두고, 배우는 언제든 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자

실무적인 고민

- 인터페이스를 무분별하게 남발하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

### 섹션 2

예제

```

H2 비즈니스 요구사항과 설계
- 회원
    • 회원을 가입하고 조회할 수 있다.
    • 회원은 일반과 VIP 두 가지 등급이 있다.
    • 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
- 주문과 할인 정책
    • 회원은 상품을 주문할 수 있다.
    • 회원 등급에 따라 할인 정책을 적용할 수 있다.
    • 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
    • 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분이다. 그렇다고 이런 정책이 결정될 때 까지 개발 을 무기한 기다릴 수 도 없다. 우리는 앞에서 배운 객체 지향 설계 방법이 있지 않은가!

인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다. 그럼 시작해보자.

*참고* 프로젝트 환경설정을 편리하게 하려고 스프링 부트를 사용한 것이다. 지금은 스프링 없는 순수한 자바로만 개발을 진행한 다는 점을 꼭 기억하자! 스프링 관련은 한참 뒤에 등장한다.
```

> 위의 예제를 직접 프로그래밍 해보면서 인터페이스와 구현체를 나누는 연습을 해보고, 실제 좋은 객체 지향 프로그래밍을 하기 위해 필요한 사항들을 통해 스프링이 어떻게 유연하고 변경에 용이하게 해주는지 확인할 예정입니다.

구현 결과

Member

- `MemberService`가 Member에 대한 생성, 조회를 담당하는 인터페이스 역할을 합니다.
- `MemberServiceImpl`가 `MemberService`의 구현체 역할을 합니다.
- `MemberRepository`가 실제 `Member`를 저장을 담당하는 인터페이스 역할을 합니다.
- `MemoryMemberRepository`가 `MemberRepository`의 실제 구현체 역할을 합니다. (이 후 자체 DB 혹은 외부 시스템 연동 시 새로운 구현체 클래스를 생성하여 사용하면 됩니다.)

Discount

- `DiscountPolicy`가 할인에 대한 인터페이스 역할을 합니다.
- `FixDiscountPolicy`가 할인 정책 중 하나를 구현한 구현체 역할을 합니다. 다른 할인 정책이 생길 경우 다른 구현체 클래스를 통해 구현하면 이전 할인 정책과 동일하게 사용 가능합니다.

Order

- `OrderService`가 상품 구매에 대한 인터페이스 역할을 합니다.
- `OrderServiceImpl`가 상품 구매에 대한 구현체 역할을 합니다.
  1. `MemberService`로부터 Member의 회원 등급을 조회
  2. `DiscountPolicy`로부터 등급에 대한 할인 금액을 확인
  3. 할인된 금액을 통해 Order 생성
  4. Order 반환

각 기능들이 인터페이스와 구현체로 나누어져 있습니다. 이로 인해 `MemberService`가 Member 데이터를 어디에 저장하는지 상관하지 않고 `MemberRepository`의 `save`와 `findById`라는 메서드를 통해 기능을 수행할 수 있습니다. 또한, OrderService는 아직 정해지지 않은 할인 정책에 상관하지 않고 `DiscountPolicy`` 인터페이스를 통해 여러 할인 정책을 상황에 따라 바꿀 수 있게 되었습니다.

하지만, 아직 수정해야하는 부분은 각 인터페이스에 대한 의존과 동시에 구현체에도 의존하고 있으므로 구현체에 대한 변경이 있을 경우 클라이언트 상에서의 변경 또한 불가피하다는 점입니다. 이 후의 강의를 통해 어떻게 수정이 되는지 확인해보도록 하겠습니다.

2월 2일

---

### 섹션 3

> 이전 섹션에서 개발 명세서를 통해 각각의 역할과 구현을 분리하여 개발을 진행했습니다. 이번 섹션에서는 새로운 할인 정책이 생겼을 때 코드 상에서 어떤 변화가 생기는지 확인하고, 객체 지향 원칙을 잘 지키고 있는지, 잘 지키고 있지 않다면 어떻게 변화를 주어야 하는지 알아보도록 하겠습니다.

새로운 할인 정책

- 이전의 할인 정책은 VIP 등급의 고객이 물건을 구매할 경우 상품의 가격에 상관없이 1000원을 할인해주는 형식이었다.
- 새로운 할인 정책은 VIP 등급의 고객이 물건을 구매할 경우 상품의 가격의 **10%**를 할인해주는 형식이다.

-> 이전의 `DiscountPolicy` 역할에 새로운 구현체를 생성해주고 `OrderServiceImpl` 상에서 새로운 구현체로 갈아끼워주면 된다.

변경사항

- 새로운 할인 정책 구현체(`RateDiscountPolicy`)를 생성
- `OrderServiceImpl`에서 `DiscountPolicy` 인터페이스에 대한 구현체를 `RateDiscountPolicy`로 변경

변경사항의 문제점

- 현재 역할과 구현을 충분히 분리해주었다. -> 인터페이스와 구현 객체로 분리
- 하지만, DIP와 OCP를 준수하지 못했다.
- DIP: 위 서비스 상에서 클라이언트 `OrderServiceImpl`는 인터페이스 `DiscountPolicy`에 의존하고 있는 상황이다. 하지만, 인터페이스뿐만 아니라 구현 클래스(`FixDiscountPolicy`, `RateDiscountPolicy`)에도 의존하고 있는 상황이다.
- OCP: 변경에는 닫혀있어야 하지만, 구현 객체의 변경이 생기면서 클라이언트의 코드를 수정해야 하는 상황이 발생했다.

클라이언트 코드에 변경이 생긴 이유

- 기대했던 것은 클라이언트가 인터페이스에만 의존하는 것이었다.
- 하지만, 실질적으로는 구현 객체들에게도 의존을하고 있는 상황
- 그렇다보니, 구현 객체의 변경이 생길 경우 클라이언트 코드에 대한 변경 또한 생기게 되었다.

문제 해결 방법

- 클라이언트가 인터페이스(추상)에만 의존하도록 해야 한다.
- 하지만, 현재 상황에서 구현체를 단순히 지우기만 한다면 `NullPointException`이 발생하개 된다.
- 그러므로, 누군가가 클라이언트가 의존하고 있는 인터페이스에 구현 객체를 대신 생성하고 주입해주어야 한다.

관심사의 분리

- 어플리케이션을 하나의 공연이라고 해보자
- 로미오와 줄리엣 공연을 하게 될 경우, 공연의 배역은 각 배역들이 지정해주는 것이 아니다.
- 즉, 로미오 역할에 디카프리오가 맡게될 경우, 줄리엣의 역할은 디카프리오가 정하는 것이 아니라는 말이다.
- 각 역할에 대한 배역을 정해주는 것은 공연의 기획부에서 하는 일이다!
- 로미오의 역할은 디카프리오가 자신의 스타일대로 구현해주는 것이고, 줄리엣 역할은 줄리엣 역할을 맡은 배우가 구현해주는 것이다. 이러한 배우들을 캐스팅하는 것은 공연의 기획부의 책임인 것이다.
- 기획부는 배우 캐스팅, 배우들은 맡은 역할에 대한 연기를 하는 것처럼 각각은 자신만의 단일 책임만을 가지고 있다.

관심사의 분리 적용

- 현재 클라이언트는 인터페이스를 선언하고 실제 구현 객체와 연결하는 책임 두 개를 가지고 있었다.
- 이 중, 클라이언트는 인터페이스에게만 의존하도록 변경해준다.
- 그리고, 클라이언트에서 의존할 인터페이스에 대한 실제 구현체의 생성과 연결은 다른 무언가(공연의 기획부)가 담당해준다.
- 클라이언트는 인터페이스를 사용만 하고, 구현 객체의 생성 및 연결은 다른 클래스가 담당하도록 해준다.

변경 사항

- 클라이언트인 `MemberService`와 `OrderService`는 현재 의존하고 있는 인터페이스와 구현 객체에서 구현 객체를 지워주고, 생성자를 통해 인터페이스에 할당할 객체들을 누군가로부터 받아올 수 있도록 해준다.
- `AppConfig`라는 클래스를 통해 `MemberService`와 `OrderService`를 생성할 수 있도록 해주고, 각 생성자 상에서 인터페이스의 구현 객체들을 생성해서 넣어준다.

-> `AppConfig`라는 클래스가 인터페이스에 대한 구현 객체 생성 및 연결을 담당하도록 한다.

-> 새로운 할인 정책을 적용하고 싶을 경우 이제는 클라이언트인 `OrderService` 상의 코드를 변경해주는 것이 아닌 AppConfig 내의 코드를 변경하면 된다.

정리

- 다형성을 통해 개발함으로써 인터페이스(추상)와 구현체(구체)의 분리를 통해 새로운 기능을 추가하는데에는 문제가 없었습니다.
- 하지만, 클라이언트가 인터페이스에 의존함과 동시에 구현체에 대해서도 의존하고 있기 때문에 새로운 기능으로 수정할 경우 클라이언트 상의 코드 또한 변경 사항이 생겼습니다.
- 이는 클라이언트 상에서 인터페이스에 대한 구현체의 생성 및 연결에 대한 역할 또한 부여되어 있기 때문이므로, 인터페이스에 대한 구현 객체의 생성 및 연결은 다른 클래스가 담당하도록 해줍니다.
- 클라이언트는 인터페이스에 대해서만 의존을 하고 생성자를 통해 구현 객체를 주입 받을 수 있도록 하고, 다른 클래스 상에서 클라이언트 클래스가 사용할 구현 객체에 대한 관리 및 주입을 해줌으로써 클라이언트는 자신의 역할만 할 수 있는 상태가 되었습니다.

좋은 객체 지향 설계의 5가지 원칙의 적용

- SRP: 클라이언트가 가지고 있던 여러 책임을 다른 클래스에 주게 되면서 자신의 책임만 담당하게 되었습니다.
- DIP: 클라이언트가 인터페이스(추상)에만 의존하고 있습니다. 어떤 구현 객체를 사용하는지 모르는 상태로 자신의 역할만 수행하게 됩니다.
- OCP: 새로운 정책으로 인해 구현 객체의 변경이 생기더라도 클라이언트 상에서는 변경이 일어나지 않습니다.

제어의 역전

- 기존의 프로그램은 스스로 필요한 객체를 생성, 연결, 실행하도록 되어 있다.
- `AppConfig`와 같은 것의 등장으로 인해 객체는 자신의 로직을 실행하는 것에만 집중하게 되었다.
- 인터페이스에 대한 구현 객체의 선택과 같은 프로그램 흐름에 대한 제어는 `AppConfig`가 담당한다.

의존 관계 주입

- 클라이언트가 의존하고 있는 인터페이스는 어떤 구현 객체가 사용될지 모른다.
- 정적인 클래스 의존 관계: 어플리케이션을 실행하지 않아도 판단할 수 있는 의존 관계 (클라이언트와 클라이언트가 의존하는 인터페이스와의 관계)
- 동적인 클래스 의존 관계: 어플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계 (클라이언트와 클라이언트가 의존하는 인터페이스에 주입된 구현 객체의 클래스와의 관계)
- 의존 관계 주입을 사용함으로써 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 의존 관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

IOC 컨테이너, DI 컨테이너

- 객체를 생성하고 관리하면서 의존관계를 연결시켜주는 것
- 의존관계 주입에 초점을 맞추고 있다.
- 어셈블러, 오브젝트 팩토리 등으로도 불린다.

스프링 코드로 변경

- 스프링 컨테이너가 관리하는 빈으로 선언하고 싶다면 해당 클래스에 `@Configuration`을 선언해주고, 원하는 메서드에 `@Bean`을 선언해준다.
- `@Configuration`을 클래스에 선언해주어야지만 스프링 컨테이너가 `@Bean`이 붙은 메서드들을 빈으로 생성하고 관리해준다고 한다.
- `ApplicationContext applicationContext = AnnotationConfigApplicationContext(AppConfig.class)`, `applicationContext.getBean(name,{클래스명}.class)`를 통해 스프링 컨테이너가 관리하고 있는 클래스를 가져올 수 있다.
- 자세한 내용은 이후에 나온다..

스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라고 한다.
- 이전 `AppConfig` 사용시 직접 객체를 생성하고 DI를 했지만, 이제 스프링 컨테이너를 통해서 사용한다.
- `@Configuration`이 붙은 클래스를 설정 정보로 사용한다. 이 클래스 상에 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 등록된 객체를 스프링 빈이라고 한다.
- 스프링 빈은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- 스프링 컨테이너에서 getBean을 통해 스프링 빈을 찾을 수 있다.

정리

- 관심사의 분리를 통해 클라이언트가 인터페이스에만 의존하도록 변경해주었다.
- 클라이언트가 사용할 구현 객체에 대한 주입을 다른 클래스(설정 정보)에서 담당해준다.
- 이처럼, 사용할 객체에 대한 흐름을 프로그래머가 제어하는 것이 아닌 다른 것에 넘겨주는 것을 제어의 역전이라고 한다.
- 스프링에서는 스프링 컨테이너가 객체들을 생성, 관리, DI 해주는 역할을 맡고 있다.

이제 스프링 컨테이너를 통해 어떤 이점을 가질 수 있는지 알아보도록 하겠습니다.

2월 3일

---

### 섹션 4

스프링 컨테이너

- `ApplicationContext` 인터페이스가 스프링 컨테이너이다.
- 스프링 컨테이너는 XML, 어노테이션 기반의 자바 설정 클래스, 커스텀 등을 통해 만들 수 있다.
- 이전의 AppConfig 클래스를 사용한 방식이 자바 설정 클래스로 스프링 컨테이너를 만든 것이다.
- `AnnotationConfigApplicationContext`가 `ApplicationContext`에 대한 구현체이고 생성자에 구성 정보 클래스를 넣어주면 스프링 컨테이너를 만들 수 있다.

스프링 컨테이너 생성 과정

- `new AnnotationConfigApplicationContext(AppConfig.class)` 를 통해 AppConfig의 설정 정보 기반 스프링 컨텍스트에 대한 구현체를 만들 수 있다.
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 기반으로 스프링 빈을 등록한다. (빈 이름은 메서드 이름으로 등록되고, 직접 부여할 수도 있다. 빈의 이름은 항상 다른 이름을 부여해주어야 한다. )
- 스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI)해줍니다.

-> 스프링 컨테이너는 XML이나 자바 설정 클래스를 기반으로 스프링 빈을 등록하고 의존 관계를 주입해준다.

빈 조회

- `AnnotationConfigApplicationContext` 객체를 활용합니다.
- `ac.getBean(빈이름, 타입)`, `ac.getBean(타입)`: 인자 정보를 가지는 빈 조회
- 조회 대상이 없을 경우 `NoSuchBeanDefinitionException` 오류 발생
- 타입으로 조회 시 같은 타입의 스프링 빈이 둘 이상이면 `NoUniqueBeanDefinitionException` 오류 발생 (빈 이름으로 조회하면 된다)
- `ac.getBeansOfType()`: 해당 타입의 빈들을 모두 조회
- 부모 타입으로 조회하면 자식 타입도 함께 조회된다. (모든 클래스의 조상인 object 클래스를 조회하면 모든 스프링 빈이 출력된다.)

BeanFactory

- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈의 관리와 조회하는 역할을 담당

ApplicationContext

- `BeanFactory`를 상속받아서 제공한다
- 빈 등록, 조회 이외에 다른 많은 일들을 한다.
- MessageSource: 메시지 소스를 활용한 국제화 기능
- EnvironmentCapable: 환경 변수 설정 관련 기능
- ApplicationEventPublisher: 어플리케이션의 이벤트 발행, 구독 모델 지원
- ResourceLoader: 파일, 클래스패스, 외부 리소스 조회 지원

스프링 컨테이너 설정 정보 제공 방식

- XML, 어노테이션 기반 자바 클래스, 커스텀 방법이 있다.
- `ApplicationContext`를 구현한 `AnnotationConfigApplicationContext`는 자바 클래스 기반 설정 정보를 읽을 수 있다.
- `ApplicationContext`를 구현한 `GenericXmlApplicationContext`는 XML 기반 설정 정보를 읽을 수 있다.
- 스프링 부트가 사용되면서 XML 기반의 설정은 잘 사용하지 않는다. 하지만, 아직 많은 레거시 프로젝트에서 XML이 사용되고 있고, XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있다.

BeanDefinition

- 스프링은 XML, 자바 클래스 기반, Groovy 등 다양한 설정 형식을 제공한다.
- 다양한 설정 방법, 커스텀 설정 방법을 제공할 수 있는 이유는 `BeanDefinition`이라는 추상화 덕분이다.
- 이 또한 역할과 구현을 나누어줌으로써 스프링 컨테이너는 설정 형식에 상관없이 `BeanDefinition`만을 통해 빈을 등록 및 의존 관계 주입을 해줄 수 있다.
- `BeanDefinition`은 빈의 설정 메타정보이다.
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
- 각각의 스프링 컨테이너 구현체들은 자신의 설정 정보를 읽을 수 있는 Reader들이 존재한다.
  - `GenericXmlApplicationContext`: `XmlBeanDefinitionReader`
  - `AnnotationConfigApplicationContext`: `AnnotatedBeanDefinitionReader`
- 각각의 Reader를 통해 설정 정보를 읽고 이를 통해 `BeanDefinition`을 생성한다.
- 새로운 형식의 설정 정보를 추가하고 싶다면, Reader를 만들어 `BeanDefinition`을 반환하도록 해주면 된다.
- `BeanDefinition`을 직접 생성해서 스프링 컨테이너에 전달할 수 있다.

정리

- 스프링 컨테이너는 XML, 어노테이션 기반 자바 클래스 등 각각의 구현체를 통해 빈을 등록할 수 있다.
- 등록된 빈은 스프링 컨테이너 구현체의 `getBean()` 메서드를 통해 가능하다.
- `ApplicationContext`의 상위 인터페이스인 `BeanFactory`가 빈의 등록이나 조회와 같은 역할을 한다.
- `ApplicationContext`는 스프링 빈 관리 이외의 여러 기능들을 수행한다.
- 스프링 컨테이너는 전달받은 `BeanDefinition`이라는 설정 메타정보 객체를 통해 빈을 등록하기 때문에 다양한 설정 형식을 가질 수 있다.
