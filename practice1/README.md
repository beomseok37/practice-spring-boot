## 배운 내용

### 섹션 1

스프링 프레임워크란?

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

스프링 부트

- 스프링을 편리하게 사용할 수 있도록 해주는 것
- 단독으로 실행할 수 있는 스프링 어플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 어떠한 라이브러리를 사용하기 위해 종속된 다른 라이브러리들까지 설치해야 되는 경우 starter 라이브러리로 한 번에 모두 설치할 수 있도록 도와준다
- 스프링과 외부 라이브러리 버전 호환을 자동으로 구성해준다.
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 설정을 해주고 바꾸고 싶은 부분은 따로 바꿀 수 있다.

스프링의 핵심 컨셉

- 스프링은 자바 언어 기반 프레임워크이다
- 자바의 가장 큰 핵심은 **"객체 지향 언어"** 라는 점이다
- 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내는 프레임워크이다.

즉, 스프링은 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크이다.

> 과거 EJB를 사용하면 EJB를 상속받아 사용하는 과정에서 EJB에 의존적으로 개발을 하게 되었다. -> 객체지향이 가진 장점을 다 잃어버리게 되었다. 그래서 순수한 자바, 객체 지향 프로그래밍으로 돌아가고자 나온 것이 POJO 등이 있는 것이다. 스프링의 DI 컨테이너 등이 객체 지향적으로 개발이 가능하도록 해주고 있다.

그렇다면 **좋은 객체 지향 프로그래밍**이란 무엇인가?

객체 지향 프로그래밍은 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받으며, 데이터를 처리할 수 있다. 객체 지향 프로그래밍은 프로그램을 **유연하고 변경이 용이하게** 만들어준다. 이는 객체 지향의 특징 중 하나인 다형성으로 설명할 수 있다.

다형성

- 세상을 역할(인터페이스)와 구현(구현체)로 나눌 수 있다.
- 운전자의 역할, 자동차의 역할이 있다면, 운전자의 구현체는 나 혹은 다른 사람이 되고 자동차의 구현체는 k3, 아반떼, 테슬라 등이 될 수 있다.
- 운전자가 자동차를 k3에서 아반떼로 바꾸어도 운전자에게는 영향을 주지 않는다.
- 운전자는 자동차의 내부 구조에 대해서 알지 못해도 상관 없다.
- 운전자에게 영향을 주지 않아도 자동차의 새로운 기능을 제공해줄 수 있다.

역할과 구현의 분리

- 역할과 구현으로 구분하면 단순해지고, 유연해지며 변경도 편리하다.
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 자바 언어의 다형성 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 구현 객체

다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

다형성의 한계

- 역할 자체가 변경된다면, 클라이언트 서버 모두 큰 변경이 발생한다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

스프링과 객체 지향

- 다형성이 가장 중요하다!
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전, 의존 관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원해준다.

좋은 객체 지향 설게의 5가지 원칙 (SOLID)

- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존관계 역전 원칙

다형성과 5원칙 위배

- OCP 위배

다형성을 통해 인터페이스와 구현체를 분리하여 개발을 진행할 수 있다. `MemberRepository` 인터페이스를 구현한 클래스 `MemoryMemberRepository`와 `JdbcMemberRepository가`` 있을 때, 앞의 클래스를 사용하다가 뒤의 클래스를 사용하기 위해서는 클라이언트의 코드를 바꿔야 되므로 OCP를 위배하게 된다.

```java
MemberRepository memberRepository = new MemoryMemberRepository();
// MemoryMemberRepository->JdbcMemberRepository로 클래스 변경
MemberRepository memberRepository = new JdbcMemberRepository();
```

- DIP 위배

위의 예시를 살펴보면 MemberRepository라는 인터페이스에 대해 의존하고 있지만, 이를 구현한 클래스인 `MemoryMemberRepository`와 `JdbcMemberRepository`에게도 의존하고 있는 형태로 존재하고 있다. 이는 DIP를 위배하게 된다.

-> 다형성만으로는 좋은 객체 지향(유연하고 변경이 용이한) 프로그래밍을 할 수 없다.

정리

- 객체 지향의 핵심은 다형성이다.
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성만으로는 인터페이스에만 의존하는 것이 아닌 구현 클래스에도 의존하게 된다.

더 쉽게 부품 갈아 끼우듯이 개발하기 위해서는 무엇인가 더 필요하다 -> **스프링!**

스프링의 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.

- **DI(Dependency Injection)**: 의존관계, 의존성 주입
- **DI 컨테이너** 제공: DI 컨테이너 내부에서 객체들을 저장하고 의존 관계를 연결해준다.

-> 클라이언트의 코드 변경 없이도 기능을 확장할 수 있다.

정리

- 모든 설계에 역할과 구현을 분리하자
- 어플리케이션 설계도 공연을 설계할 때처럼 배역만 만들어두고, 배우는 언제든 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자

실무적인 고민

- 인터페이스를 무분별하게 남발하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

### 섹션 2

예제

```

H2 비즈니스 요구사항과 설계
- 회원
    • 회원을 가입하고 조회할 수 있다.
    • 회원은 일반과 VIP 두 가지 등급이 있다.
    • 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
- 주문과 할인 정책
    • 회원은 상품을 주문할 수 있다.
    • 회원 등급에 따라 할인 정책을 적용할 수 있다.
    • 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
    • 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분이다. 그렇다고 이런 정책이 결정될 때 까지 개발 을 무기한 기다릴 수 도 없다. 우리는 앞에서 배운 객체 지향 설계 방법이 있지 않은가!

인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다. 그럼 시작해보자.

*참고* 프로젝트 환경설정을 편리하게 하려고 스프링 부트를 사용한 것이다. 지금은 스프링 없는 순수한 자바로만 개발을 진행한 다는 점을 꼭 기억하자! 스프링 관련은 한참 뒤에 등장한다.
```

> 위의 예제를 직접 프로그래밍 해보면서 인터페이스와 구현체를 나누는 연습을 해보고, 실제 좋은 객체 지향 프로그래밍을 하기 위해 필요한 사항들을 통해 스프링이 어떻게 유연하고 변경에 용이하게 해주는지 확인할 예정입니다.

구현 결과

Member

- `MemberService`가 Member에 대한 생성, 조회를 담당하는 인터페이스 역할을 합니다.
- `MemberServiceImpl`가 `MemberService`의 구현체 역할을 합니다.
- `MemberRepository`가 실제 `Member`를 저장을 담당하는 인터페이스 역할을 합니다.
- `MemoryMemberRepository`가 `MemberRepository`의 실제 구현체 역할을 합니다. (이 후 자체 DB 혹은 외부 시스템 연동 시 새로운 구현체 클래스를 생성하여 사용하면 됩니다.)

Discount

- `DiscountPolicy`가 할인에 대한 인터페이스 역할을 합니다.
- `FixDiscountPolicy`가 할인 정책 중 하나를 구현한 구현체 역할을 합니다. 다른 할인 정책이 생길 경우 다른 구현체 클래스를 통해 구현하면 이전 할인 정책과 동일하게 사용 가능합니다.

Order

- `OrderService`가 상품 구매에 대한 인터페이스 역할을 합니다.
- `OrderServiceImpl`가 상품 구매에 대한 구현체 역할을 합니다.
  1. `MemberService`로부터 Member의 회원 등급을 조회
  2. `DiscountPolicy`로부터 등급에 대한 할인 금액을 확인
  3. 할인된 금액을 통해 Order 생성
  4. Order 반환

각 기능들이 인터페이스와 구현체로 나누어져 있습니다. 이로 인해 `MemberService`가 Member 데이터를 어디에 저장하는지 상관하지 않고 `MemberRepository`의 `save`와 `findById`라는 메서드를 통해 기능을 수행할 수 있습니다. 또한, OrderService는 아직 정해지지 않은 할인 정책에 상관하지 않고 `DiscountPolicy`` 인터페이스를 통해 여러 할인 정책을 상황에 따라 바꿀 수 있게 되었습니다.

하지만, 아직 수정해야하는 부분은 각 인터페이스에 대한 의존과 동시에 구현체에도 의존하고 있으므로 구현체에 대한 변경이 있을 경우 클라이언트 상에서의 변경 또한 불가피하다는 점입니다. 이 후의 강의를 통해 어떻게 수정이 되는지 확인해보도록 하겠습니다.

2월 2일

---
